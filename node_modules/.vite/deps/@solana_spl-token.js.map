{
  "version": 3,
  "sources": ["../../@solana/spl-token/src/index.ts", "../../@solana/spl-token/src/actions/index.ts", "../../@solana/spl-token/src/actions/amountToUiAmount.ts", "../../@solana/spl-token/src/constants.ts", "../../@solana/spl-token/src/instructions/amountToUiAmount.ts", "../../@solana/spl-token/src/errors.ts", "../../@solana/spl-token/src/instructions/types.ts", "../../@solana/spl-token/src/state/mint.ts", "../../@solana/spl-token/src/extensions/accountType.ts", "../../@solana/spl-token/src/extensions/extensionType.ts", "../../@solana/spl-token/src/state/account.ts", "../../@solana/spl-token/src/state/multisig.ts", "../../@solana/spl-token/src/extensions/cpiGuard/index.ts", "../../@solana/spl-token/src/extensions/cpiGuard/actions.ts", "../../@solana/spl-token/src/actions/internal.ts", "../../@solana/spl-token/src/extensions/cpiGuard/instructions.ts", "../../@solana/spl-token/src/instructions/internal.ts", "../../@solana/spl-token/src/extensions/cpiGuard/state.ts", "../../@solana/spl-token/src/extensions/defaultAccountState/index.ts", "../../@solana/spl-token/src/extensions/defaultAccountState/actions.ts", "../../@solana/spl-token/src/extensions/defaultAccountState/instructions.ts", "../../@solana/spl-token/src/extensions/defaultAccountState/state.ts", "../../@solana/spl-token/src/extensions/tokenGroup/index.ts", "../../@solana/spl-token/src/extensions/tokenGroup/actions.ts", "../../@solana/spl-token-group/src/index.ts", "../../@solana/spl-token-group/src/errors.ts", "../../@solana/spl-token-group/src/instruction.ts", "../../@solana/spl-token-group/src/state/index.ts", "../../@solana/spl-token-group/src/state/tokenGroup.ts", "../../@solana/spl-token-group/src/state/tokenGroupMember.ts", "../../@solana/spl-token/src/extensions/tokenGroup/state.ts", "../../@solana/spl-token/src/extensions/groupMemberPointer/state.ts", "../../@solana/spl-token/src/extensions/groupPointer/state.ts", "../../@solana/spl-token/src/extensions/immutableOwner.ts", "../../@solana/spl-token/src/extensions/interestBearingMint/state.ts", "../../@solana/spl-token/src/extensions/memoTransfer/index.ts", "../../@solana/spl-token/src/extensions/memoTransfer/actions.ts", "../../@solana/spl-token/src/extensions/memoTransfer/instructions.ts", "../../@solana/spl-token/src/extensions/memoTransfer/state.ts", "../../@solana/spl-token/src/extensions/metadataPointer/state.ts", "../../@solana/spl-token/src/extensions/mintCloseAuthority.ts", "../../@solana/spl-token/src/extensions/nonTransferable.ts", "../../@solana/spl-token/src/extensions/pausable/index.ts", "../../@solana/spl-token/src/extensions/pausable/actions.ts", "../../@solana/spl-token/src/extensions/pausable/instructions.ts", "../../@solana/spl-token/src/extensions/pausable/state.ts", "../../@solana/spl-token/src/extensions/permanentDelegate.ts", "../../@solana/spl-token/src/extensions/scaledUiAmount/index.ts", "../../@solana/spl-token/src/extensions/scaledUiAmount/actions.ts", "../../@solana/spl-token/src/extensions/scaledUiAmount/instructions.ts", "../../@solana/spl-token/src/extensions/scaledUiAmount/state.ts", "../../@solana/spl-token/src/extensions/transferFee/index.ts", "../../@solana/spl-token/src/extensions/transferFee/actions.ts", "../../@solana/spl-token/src/extensions/transferFee/instructions.ts", "../../@solana/spl-token/src/serialization.ts", "../../@solana/spl-token/src/extensions/transferFee/state.ts", "../../@solana/spl-token/src/extensions/transferHook/index.ts", "../../@solana/spl-token/src/extensions/transferHook/actions.ts", "../../@solana/spl-token/src/extensions/transferHook/instructions.ts", "../../@solana/spl-token/src/instructions/transferChecked.ts", "../../@solana/spl-token/src/extensions/transferHook/state.ts", "../../@solana/spl-token/src/extensions/transferHook/seeds.ts", "../../@solana/spl-token/src/extensions/transferHook/pubkeyData.ts", "../../@solana/spl-token/src/actions/approve.ts", "../../@solana/spl-token/src/instructions/approve.ts", "../../@solana/spl-token/src/actions/approveChecked.ts", "../../@solana/spl-token/src/instructions/approveChecked.ts", "../../@solana/spl-token/src/actions/burn.ts", "../../@solana/spl-token/src/instructions/burn.ts", "../../@solana/spl-token/src/actions/burnChecked.ts", "../../@solana/spl-token/src/instructions/burnChecked.ts", "../../@solana/spl-token/src/actions/closeAccount.ts", "../../@solana/spl-token/src/instructions/closeAccount.ts", "../../@solana/spl-token/src/actions/createAccount.ts", "../../@solana/spl-token/src/instructions/initializeAccount.ts", "../../@solana/spl-token/src/actions/createAssociatedTokenAccount.ts", "../../@solana/spl-token/src/instructions/associatedTokenAccount.ts", "../../@solana/spl-token/src/actions/createAssociatedTokenAccountIdempotent.ts", "../../@solana/spl-token/src/actions/createMint.ts", "../../@solana/spl-token/src/instructions/initializeMint2.ts", "../../@solana/spl-token/src/actions/createMultisig.ts", "../../@solana/spl-token/src/instructions/initializeMultisig.ts", "../../@solana/spl-token/src/actions/createNativeMint.ts", "../../@solana/spl-token/src/instructions/createNativeMint.ts", "../../@solana/spl-token/src/actions/createWrappedNativeAccount.ts", "../../@solana/spl-token/src/instructions/syncNative.ts", "../../@solana/spl-token/src/actions/freezeAccount.ts", "../../@solana/spl-token/src/instructions/freezeAccount.ts", "../../@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts", "../../@solana/spl-token/src/actions/mintTo.ts", "../../@solana/spl-token/src/instructions/mintTo.ts", "../../@solana/spl-token/src/actions/mintToChecked.ts", "../../@solana/spl-token/src/instructions/mintToChecked.ts", "../../@solana/spl-token/src/actions/recoverNested.ts", "../../@solana/spl-token/src/actions/revoke.ts", "../../@solana/spl-token/src/instructions/revoke.ts", "../../@solana/spl-token/src/actions/setAuthority.ts", "../../@solana/spl-token/src/instructions/setAuthority.ts", "../../@solana/spl-token/src/actions/syncNative.ts", "../../@solana/spl-token/src/actions/thawAccount.ts", "../../@solana/spl-token/src/instructions/thawAccount.ts", "../../@solana/spl-token/src/actions/transfer.ts", "../../@solana/spl-token/src/instructions/transfer.ts", "../../@solana/spl-token/src/actions/transferChecked.ts", "../../@solana/spl-token/src/actions/uiAmountToAmount.ts", "../../@solana/spl-token/src/instructions/uiAmountToAmount.ts", "../../@solana/spl-token/src/extensions/index.ts", "../../@solana/spl-token/src/extensions/groupMemberPointer/index.ts", "../../@solana/spl-token/src/extensions/groupMemberPointer/instructions.ts", "../../@solana/spl-token/src/extensions/groupPointer/index.ts", "../../@solana/spl-token/src/extensions/groupPointer/instructions.ts", "../../@solana/spl-token/src/extensions/interestBearingMint/index.ts", "../../@solana/spl-token/src/extensions/interestBearingMint/actions.ts", "../../@solana/spl-token/src/instructions/initializeMint.ts", "../../@solana/spl-token/src/extensions/interestBearingMint/instructions.ts", "../../@solana/spl-token/src/extensions/metadataPointer/index.ts", "../../@solana/spl-token/src/extensions/metadataPointer/instructions.ts", "../../@solana/spl-token/src/extensions/tokenMetadata/index.ts", "../../@solana/spl-token/src/extensions/tokenMetadata/actions.ts", "../../@solana/spl-token/src/extensions/tokenMetadata/state.ts", "../../@solana/spl-token/src/state/index.ts", "../../@solana/spl-token/src/instructions/index.ts", "../../@solana/spl-token/src/instructions/decode.ts", "../../@solana/spl-token/src/instructions/initializeAccount2.ts", "../../@solana/spl-token/src/instructions/initializeAccount3.ts", "../../@solana/spl-token/lib/esm/instructions/initializeMultisig2.js", "../../@solana/spl-token/src/instructions/initializeImmutableOwner.ts", "../../@solana/spl-token/src/instructions/initializeMintCloseAuthority.ts", "../../@solana/spl-token/src/instructions/reallocate.ts", "../../@solana/spl-token/src/instructions/initializeNonTransferableMint.ts", "../../@solana/spl-token/src/instructions/initializePermanentDelegate.ts"],
  "sourcesContent": ["export * from './actions/index.js';\nexport * from './constants.js';\nexport * from './errors.js';\nexport * from './extensions/index.js';\nexport * from './instructions/index.js';\nexport * from './state/index.js';\n", "export * from './amountToUiAmount.js';\nexport * from './approve.js';\nexport * from './approveChecked.js';\nexport * from './burn.js';\nexport * from './burnChecked.js';\nexport * from './closeAccount.js';\nexport * from './createAccount.js';\nexport * from './createAssociatedTokenAccount.js';\nexport * from './createAssociatedTokenAccountIdempotent.js';\nexport * from './createMint.js';\nexport * from './createMultisig.js';\nexport * from './createNativeMint.js';\nexport * from './createWrappedNativeAccount.js';\nexport * from './freezeAccount.js';\nexport * from './getOrCreateAssociatedTokenAccount.js';\nexport * from './mintTo.js';\nexport * from './mintToChecked.js';\nexport * from './recoverNested.js';\nexport * from './revoke.js';\nexport * from './setAuthority.js';\nexport * from './syncNative.js';\nexport * from './thawAccount.js';\nexport * from './transfer.js';\nexport * from './transferChecked.js';\nexport * from './uiAmountToAmount.js';\n", "import type { Connection, Signer, TransactionError } from '@solana/web3.js';\nimport { PublicKey, Transaction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAmountToUiAmountInstruction } from '../instructions/amountToUiAmount.js';\nimport { unpackMint } from '../state/mint.js';\nimport { getInterestBearingMintConfigState } from '../extensions/interestBearingMint/state.js';\n\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Amount of tokens to be converted to Ui Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | bigint,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<string | TransactionError | null> {\n    const transaction = new Transaction().add(createAmountToUiAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData?.data) {\n        return Buffer.from(returnData.data[0], returnData.data[1]).toString('utf-8');\n    }\n    return err;\n}\n\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r - The interest rate in basis points.\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1: number, t2: number, r: number) {\n    const ONE_IN_BASIS_POINTS = 10000;\n    const SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\n    const timespan = t2 - t1;\n    const numerator = r * timespan;\n    const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n    return Math.exp(exponent);\n}\n\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param connection - The Solana connection object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(connection: Connection): Promise<number> {\n    const info = await connection.getParsedAccountInfo(new PublicKey('SysvarC1ock11111111111111111111111111111111'));\n    if (!info) {\n        throw new Error('Failed to fetch sysvar clock');\n    }\n    if (typeof info.value === 'object' && info.value && 'data' in info.value && 'parsed' in info.value.data) {\n        return info.value.data.parsed.info.unixTimestamp;\n    }\n    throw new Error('Failed to parse sysvar clock');\n}\n\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n * In general to calculate compounding interest over a period of time, the formula is:\n * A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountWithoutSimulation(\n    amount: bigint,\n    decimals: number,\n    currentTimestamp: number, // in seconds\n    lastUpdateTimestamp: number,\n    initializationTimestamp: number,\n    preUpdateAverageRate: number,\n    currentRate: number,\n): string {\n    // Calculate pre-update exponent\n    // e^(preUpdateAverageRate * (lastUpdateTimestamp - initializationTimestamp) / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS))\n    const preUpdateExp = calculateExponentForTimesAndRate(\n        initializationTimestamp,\n        lastUpdateTimestamp,\n        preUpdateAverageRate,\n    );\n\n    // Calculate post-update exponent\n    // e^(currentRate * (currentTimestamp - lastUpdateTimestamp) / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS))\n    const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n\n    // Calculate total scale\n    const totalScale = preUpdateExp * postUpdateExp;\n    // Scale the amount by the total interest factor\n    const scaledAmount = Number(amount) * totalScale;\n\n    // Calculate the decimal factor (e.g. 100 for 2 decimals)\n    const decimalFactor = Math.pow(10, decimals);\n\n    // Convert to UI amount by:\n    // 1. Truncating to remove any remaining decimals\n    // 2. Dividing by decimal factor to get final UI amount\n    // 3. Converting to string\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in /token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in /token/program/src/processor.rs\n *\n * @param connection     Connection to use\n * @param mint           Mint to use for calculations\n * @param amount         Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(\n    connection: Connection,\n    mint: PublicKey,\n    amount: bigint,\n): Promise<string> {\n    const accountInfo = await connection.getAccountInfo(mint);\n    const programId = accountInfo?.owner;\n    if (programId !== TOKEN_PROGRAM_ID && programId !== TOKEN_2022_PROGRAM_ID) {\n        throw new Error('Invalid program ID');\n    }\n\n    const mintInfo = unpackMint(mint, accountInfo, programId);\n\n    const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);\n    if (!interestBearingMintConfigState) {\n        const amountNumber = Number(amount);\n        const decimalsFactor = Math.pow(10, mintInfo.decimals);\n        return (amountNumber / decimalsFactor).toString();\n    }\n\n    const timestamp = await getSysvarClockTimestamp(connection);\n\n    return amountToUiAmountWithoutSimulation(\n        amount,\n        mintInfo.decimals,\n        timestamp,\n        Number(interestBearingMintConfigState.lastUpdateTimestamp),\n        Number(interestBearingMintConfigState.initializationTimestamp),\n        interestBearingMintConfigState.preUpdateAverageRate,\n        interestBearingMintConfigState.currentRate,\n    );\n}\n\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate              Current interest rate in basis points\n *\n * In general to calculate the principal from the UI amount, the formula is:\n * P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n *\n * In this case, we are calculating the principal by dividing the UI amount by the total scale factor which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 is the pre-update average rate, r2 is the current rate, t1 is the time in years between the initialization timestamp and the last update timestamp,\n * and t2 is the time in years between the last update timestamp and the current timestamp.\n * then to calculate the principal, we divide the UI amount by the total scale factor:\n * P = A / totalScale\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountWithoutSimulation(\n    uiAmount: string,\n    decimals: number,\n    currentTimestamp: number, // in seconds\n    lastUpdateTimestamp: number,\n    initializationTimestamp: number,\n    preUpdateAverageRate: number,\n    currentRate: number,\n): bigint {\n    const uiAmountNumber = parseFloat(uiAmount);\n    const decimalsFactor = Math.pow(10, decimals);\n    const uiAmountScaled = uiAmountNumber * decimalsFactor;\n\n    // Calculate pre-update exponent\n    const preUpdateExp = calculateExponentForTimesAndRate(\n        initializationTimestamp,\n        lastUpdateTimestamp,\n        preUpdateAverageRate,\n    );\n\n    // Calculate post-update exponent\n    const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n\n    // Calculate total scale\n    const totalScale = preUpdateExp * postUpdateExp;\n\n    // Calculate original principal by dividing the UI amount (principal + interest) by the total scale\n    const originalPrincipal = uiAmountScaled / totalScale;\n    return BigInt(Math.trunc(originalPrincipal));\n}\n\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param connection     Connection to use\n * @param mint           Mint to use for calculations\n * @param uiAmount       UI Amount to be converted back to raw amount\n *\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(\n    connection: Connection,\n    mint: PublicKey,\n    uiAmount: string,\n): Promise<bigint> {\n    const accountInfo = await connection.getAccountInfo(mint);\n    const programId = accountInfo?.owner;\n    if (programId !== TOKEN_PROGRAM_ID && programId !== TOKEN_2022_PROGRAM_ID) {\n        throw new Error('Invalid program ID');\n    }\n\n    const mintInfo = unpackMint(mint, accountInfo, programId);\n    const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);\n    if (!interestBearingMintConfigState) {\n        const uiAmountScaled = parseFloat(uiAmount) * Math.pow(10, mintInfo.decimals);\n        return BigInt(Math.trunc(uiAmountScaled));\n    }\n\n    const timestamp = await getSysvarClockTimestamp(connection);\n\n    return uiAmountToAmountWithoutSimulation(\n        uiAmount,\n        mintInfo.decimals,\n        timestamp,\n        Number(interestBearingMintConfigState.lastUpdateTimestamp),\n        Number(interestBearingMintConfigState.initializationTimestamp),\n        interestBearingMintConfigState.preUpdateAverageRate,\n        interestBearingMintConfigState.currentRate,\n    );\n}\n", "import { PublicKey } from '@solana/web3.js';\n\n/** Address of the SPL Token program */\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\n\n/** Address of the SPL Token 2022 program */\nexport const TOKEN_2022_PROGRAM_ID = new PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');\n\n/** Address of the SPL Associated Token Account program */\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\n/** Address of the special mint for wrapped native SOL in spl-token */\nexport const NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n\n/** Address of the special mint for wrapped native SOL in spl-token-2022 */\nexport const NATIVE_MINT_2022 = new PublicKey('9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP');\n\n/** Check that the token program provided is not `Tokenkeg...`, useful when using extensions */\nexport function programSupportsExtensions(programId: PublicKey): boolean {\n    if (programId.equals(TOKEN_PROGRAM_ID)) {\n        return false;\n    } else {\n        return true;\n    }\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface AmountToUiAmountInstructionData {\n    instruction: TokenInstruction.AmountToUiAmount;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const amountToUiAmountInstructionData = struct<AmountToUiAmountInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n]);\n\n/**\n * Construct a AmountToUiAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       Amount of tokens to be converted to UiAmount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAmountToUiAmountInstruction(\n    mint: PublicKey,\n    amount: number | bigint,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n\n    const data = Buffer.alloc(amountToUiAmountInstructionData.span);\n    amountToUiAmountInstructionData.encode(\n        {\n            instruction: TokenInstruction.AmountToUiAmount,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid AmountToUiAmount instruction */\nexport interface DecodedAmountToUiAmountInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.AmountToUiAmount;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a AmountToUiAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeAmountToUiAmountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedAmountToUiAmountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== amountToUiAmountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeAmountToUiAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.AmountToUiAmount) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated AmountToUiAmount instruction */\nexport interface DecodedAmountToUiAmountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a AmountToUiAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeAmountToUiAmountInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedAmountToUiAmountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: amountToUiAmountInstructionData.decode(data),\n    };\n}\n", "/** Base class for errors */\nexport abstract class TokenError extends Error {\n    constructor(message?: string) {\n        super(message);\n    }\n}\n\n/** Thrown if an account is not found at the expected address */\nexport class TokenAccountNotFoundError extends TokenError {\n    name = 'TokenAccountNotFoundError';\n}\n\n/** Thrown if a program state account is not a valid Account */\nexport class TokenInvalidAccountError extends TokenError {\n    name = 'TokenInvalidAccountError';\n}\n\n/** Thrown if a program state account does not contain valid data */\nexport class TokenInvalidAccountDataError extends TokenError {\n    name = 'TokenInvalidAccountDataError';\n}\n\n/** Thrown if a program state account is not owned by the expected token program */\nexport class TokenInvalidAccountOwnerError extends TokenError {\n    name = 'TokenInvalidAccountOwnerError';\n}\n\n/** Thrown if the byte length of an program state account doesn't match the expected size */\nexport class TokenInvalidAccountSizeError extends TokenError {\n    name = 'TokenInvalidAccountSizeError';\n}\n\n/** Thrown if the mint of a token account doesn't match the expected mint */\nexport class TokenInvalidMintError extends TokenError {\n    name = 'TokenInvalidMintError';\n}\n\n/** Thrown if the owner of a token account doesn't match the expected owner */\nexport class TokenInvalidOwnerError extends TokenError {\n    name = 'TokenInvalidOwnerError';\n}\n\n/** Thrown if the owner of a token account is a PDA (Program Derived Address) */\nexport class TokenOwnerOffCurveError extends TokenError {\n    name = 'TokenOwnerOffCurveError';\n}\n\n/** Thrown if an instruction's program is invalid */\nexport class TokenInvalidInstructionProgramError extends TokenError {\n    name = 'TokenInvalidInstructionProgramError';\n}\n\n/** Thrown if an instruction's keys are invalid */\nexport class TokenInvalidInstructionKeysError extends TokenError {\n    name = 'TokenInvalidInstructionKeysError';\n}\n\n/** Thrown if an instruction's data is invalid */\nexport class TokenInvalidInstructionDataError extends TokenError {\n    name = 'TokenInvalidInstructionDataError';\n}\n\n/** Thrown if an instruction's type is invalid */\nexport class TokenInvalidInstructionTypeError extends TokenError {\n    name = 'TokenInvalidInstructionTypeError';\n}\n\n/** Thrown if the program does not support the desired instruction */\nexport class TokenUnsupportedInstructionError extends TokenError {\n    name = 'TokenUnsupportedInstructionError';\n}\n\n/** Thrown if the transfer hook extra accounts contains an invalid account index */\nexport class TokenTransferHookAccountNotFound extends TokenError {\n    name = 'TokenTransferHookAccountNotFound';\n}\n\n/** Thrown if the transfer hook extra accounts contains an invalid seed */\nexport class TokenTransferHookInvalidSeed extends TokenError {\n    name = 'TokenTransferHookInvalidSeed';\n}\n\n/** Thrown if account data required by an extra account meta seed config could not be fetched */\nexport class TokenTransferHookAccountDataNotFound extends TokenError {\n    name = 'TokenTransferHookAccountDataNotFound';\n}\n\n/** Thrown if pubkey data extra accounts config is invalid */\nexport class TokenTransferHookInvalidPubkeyData extends TokenError {\n    name = 'TokenTransferHookInvalidPubkeyData';\n}\n\n/** Thrown if pubkey data source is too small for a pubkey */\nexport class TokenTransferHookPubkeyDataTooSmall extends TokenError {\n    name = 'TokenTransferHookPubkeyDataTooSmall';\n}\n", "/** Instructions defined by the program */\nexport enum TokenInstruction {\n    InitializeMint = 0,\n    InitializeAccount = 1,\n    InitializeMultisig = 2,\n    Transfer = 3,\n    Approve = 4,\n    Revoke = 5,\n    SetAuthority = 6,\n    MintTo = 7,\n    Burn = 8,\n    CloseAccount = 9,\n    FreezeAccount = 10,\n    ThawAccount = 11,\n    TransferChecked = 12,\n    ApproveChecked = 13,\n    MintToChecked = 14,\n    BurnChecked = 15,\n    InitializeAccount2 = 16,\n    SyncNative = 17,\n    InitializeAccount3 = 18,\n    InitializeMultisig2 = 19,\n    InitializeMint2 = 20,\n    GetAccountDataSize = 21,\n    InitializeImmutableOwner = 22,\n    AmountToUiAmount = 23,\n    UiAmountToAmount = 24,\n    InitializeMintCloseAuthority = 25,\n    TransferFeeExtension = 26,\n    ConfidentialTransferExtension = 27,\n    DefaultAccountStateExtension = 28,\n    Reallocate = 29,\n    MemoTransferExtension = 30,\n    CreateNativeMint = 31,\n    InitializeNonTransferableMint = 32,\n    InterestBearingMintExtension = 33,\n    CpiGuardExtension = 34,\n    InitializePermanentDelegate = 35,\n    TransferHookExtension = 36,\n    // ConfidentialTransferFeeExtension = 37,\n    // WithdrawalExcessLamports = 38,\n    MetadataPointerExtension = 39,\n    GroupPointerExtension = 40,\n    GroupMemberPointerExtension = 41,\n    // ConfidentialMintBurnExtension = 42,\n    ScaledUiAmountExtension = 43,\n    PausableExtension = 44,\n}\n", "import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n    TokenInvalidMintError,\n    TokenOwnerOffCurveError,\n} from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n\n/** Information about a mint */\nexport interface Mint {\n    /** Address of the mint */\n    address: PublicKey;\n    /**\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\n     */\n    mintAuthority: PublicKey | null;\n    /** Total supply of tokens */\n    supply: bigint;\n    /** Number of base 10 digits to the right of the decimal place */\n    decimals: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Optional authority to freeze token accounts */\n    freezeAuthority: PublicKey | null;\n    /** Additional data for extension */\n    tlvData: Buffer;\n}\n\n/** Mint as stored by the program */\nexport interface RawMint {\n    mintAuthorityOption: 1 | 0;\n    mintAuthority: PublicKey;\n    supply: bigint;\n    decimals: number;\n    isInitialized: boolean;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct<RawMint>([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Mint> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n}\n\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nexport function unpackMint(address: PublicKey, info: AccountInfo<Buffer> | null, programId = TOKEN_PROGRAM_ID): Mint {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < MINT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > MINT_SIZE) {\n        if (info.data.length <= ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint) throw new TokenInvalidMintError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n        tlvData,\n    };\n}\n\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(\n    connection: Connection,\n    commitment?: Commitment,\n): Promise<number> {\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(\n    connection: Connection,\n    extensions: ExtensionType[],\n    commitment?: Commitment,\n): Promise<number> {\n    const mintLen = getMintLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nexport async function getAssociatedTokenAddress(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = await PublicKey.findProgramAddress(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId,\n    );\n\n    return address;\n}\n\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport function getAssociatedTokenAddressSync(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): PublicKey {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = PublicKey.findProgramAddressSync(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId,\n    );\n\n    return address;\n}\n", "export enum AccountType {\n    Uninitialized,\n    Mint,\n    Account,\n}\nexport const ACCOUNT_TYPE_SIZE = 1;\n", "import type { AccountInfo, PublicKey } from '@solana/web3.js';\n\nimport { ACCOUNT_SIZE } from '../state/account.js';\nimport type { Mint } from '../state/mint.js';\nimport { MINT_SIZE, unpackMint } from '../state/mint.js';\nimport { MULTISIG_SIZE } from '../state/multisig.js';\nimport { ACCOUNT_TYPE_SIZE } from './accountType.js';\nimport { CPI_GUARD_SIZE } from './cpiGuard/index.js';\nimport { DEFAULT_ACCOUNT_STATE_SIZE } from './defaultAccountState/index.js';\nimport { TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE } from './tokenGroup/index.js';\nimport { GROUP_MEMBER_POINTER_SIZE } from './groupMemberPointer/state.js';\nimport { GROUP_POINTER_SIZE } from './groupPointer/state.js';\nimport { IMMUTABLE_OWNER_SIZE } from './immutableOwner.js';\nimport { INTEREST_BEARING_MINT_CONFIG_STATE_SIZE } from './interestBearingMint/state.js';\nimport { MEMO_TRANSFER_SIZE } from './memoTransfer/index.js';\nimport { METADATA_POINTER_SIZE } from './metadataPointer/state.js';\nimport { MINT_CLOSE_AUTHORITY_SIZE } from './mintCloseAuthority.js';\nimport { NON_TRANSFERABLE_SIZE, NON_TRANSFERABLE_ACCOUNT_SIZE } from './nonTransferable.js';\nimport { PAUSABLE_CONFIG_SIZE, PAUSABLE_ACCOUNT_SIZE } from './pausable/index.js';\nimport { PERMANENT_DELEGATE_SIZE } from './permanentDelegate.js';\nimport { SCALED_UI_AMOUNT_CONFIG_SIZE } from './scaledUiAmount/index.js';\nimport { TRANSFER_FEE_AMOUNT_SIZE, TRANSFER_FEE_CONFIG_SIZE } from './transferFee/index.js';\nimport { TRANSFER_HOOK_ACCOUNT_SIZE, TRANSFER_HOOK_SIZE } from './transferHook/index.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../constants.js';\n\n// Sequence from https://github.com/solana-labs/solana-program-library/blob/master/token/program-2022/src/extension/mod.rs#L903\nexport enum ExtensionType {\n    Uninitialized,\n    TransferFeeConfig,\n    TransferFeeAmount,\n    MintCloseAuthority,\n    ConfidentialTransferMint,\n    ConfidentialTransferAccount,\n    DefaultAccountState,\n    ImmutableOwner,\n    MemoTransfer,\n    NonTransferable,\n    InterestBearingConfig,\n    CpiGuard,\n    PermanentDelegate,\n    NonTransferableAccount,\n    TransferHook,\n    TransferHookAccount,\n    // ConfidentialTransferFee, // Not implemented yet\n    // ConfidentialTransferFeeAmount, // Not implemented yet\n    MetadataPointer = 18, // Remove number once above extensions implemented\n    TokenMetadata = 19, // Remove number once above extensions implemented\n    GroupPointer = 20,\n    TokenGroup = 21,\n    GroupMemberPointer = 22,\n    TokenGroupMember = 23,\n    // ConfidentialMintBurn, // Not implemented yet\n    ScaledUiAmountConfig = 25,\n    PausableConfig = 26,\n    PausableAccount = 27,\n}\n\nexport const TYPE_SIZE = 2;\nexport const LENGTH_SIZE = 2;\n\nfunction addTypeAndLengthToLen(len: number): number {\n    return len + TYPE_SIZE + LENGTH_SIZE;\n}\n\nfunction isVariableLengthExtension(e: ExtensionType): boolean {\n    switch (e) {\n        case ExtensionType.TokenMetadata:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// NOTE: All of these should eventually use their type's Span instead of these\n// constants.  This is provided for at least creation to work.\nexport function getTypeLen(e: ExtensionType): number {\n    switch (e) {\n        case ExtensionType.Uninitialized:\n            return 0;\n        case ExtensionType.TransferFeeConfig:\n            return TRANSFER_FEE_CONFIG_SIZE;\n        case ExtensionType.TransferFeeAmount:\n            return TRANSFER_FEE_AMOUNT_SIZE;\n        case ExtensionType.MintCloseAuthority:\n            return MINT_CLOSE_AUTHORITY_SIZE;\n        case ExtensionType.ConfidentialTransferMint:\n            return 65;\n        case ExtensionType.ConfidentialTransferAccount:\n            return 295;\n        case ExtensionType.CpiGuard:\n            return CPI_GUARD_SIZE;\n        case ExtensionType.DefaultAccountState:\n            return DEFAULT_ACCOUNT_STATE_SIZE;\n        case ExtensionType.ImmutableOwner:\n            return IMMUTABLE_OWNER_SIZE;\n        case ExtensionType.MemoTransfer:\n            return MEMO_TRANSFER_SIZE;\n        case ExtensionType.MetadataPointer:\n            return METADATA_POINTER_SIZE;\n        case ExtensionType.NonTransferable:\n            return NON_TRANSFERABLE_SIZE;\n        case ExtensionType.InterestBearingConfig:\n            return INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;\n        case ExtensionType.PermanentDelegate:\n            return PERMANENT_DELEGATE_SIZE;\n        case ExtensionType.NonTransferableAccount:\n            return NON_TRANSFERABLE_ACCOUNT_SIZE;\n        case ExtensionType.TransferHook:\n            return TRANSFER_HOOK_SIZE;\n        case ExtensionType.TransferHookAccount:\n            return TRANSFER_HOOK_ACCOUNT_SIZE;\n        case ExtensionType.GroupPointer:\n            return GROUP_POINTER_SIZE;\n        case ExtensionType.GroupMemberPointer:\n            return GROUP_MEMBER_POINTER_SIZE;\n        case ExtensionType.TokenGroup:\n            return TOKEN_GROUP_SIZE;\n        case ExtensionType.TokenGroupMember:\n            return TOKEN_GROUP_MEMBER_SIZE;\n        case ExtensionType.ScaledUiAmountConfig:\n            return SCALED_UI_AMOUNT_CONFIG_SIZE;\n        case ExtensionType.PausableConfig:\n            return PAUSABLE_CONFIG_SIZE;\n        case ExtensionType.PausableAccount:\n            return PAUSABLE_ACCOUNT_SIZE;\n        case ExtensionType.TokenMetadata:\n            throw Error(`Cannot get type length for variable extension type: ${e}`);\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\n\nexport function isMintExtension(e: ExtensionType): boolean {\n    switch (e) {\n        case ExtensionType.TransferFeeConfig:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.ConfidentialTransferMint:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.NonTransferable:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.TransferHook:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableConfig:\n            return true;\n        case ExtensionType.Uninitialized:\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.PausableAccount:\n            return false;\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\n\nexport function isAccountExtension(e: ExtensionType): boolean {\n    switch (e) {\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.PausableAccount:\n            return true;\n        case ExtensionType.Uninitialized:\n        case ExtensionType.TransferFeeConfig:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.ConfidentialTransferMint:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.NonTransferable:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.TransferHook:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableConfig:\n            return false;\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\n\nexport function getAccountTypeOfMintType(e: ExtensionType): ExtensionType {\n    switch (e) {\n        case ExtensionType.TransferFeeConfig:\n            return ExtensionType.TransferFeeAmount;\n        case ExtensionType.ConfidentialTransferMint:\n            return ExtensionType.ConfidentialTransferAccount;\n        case ExtensionType.NonTransferable:\n            return ExtensionType.NonTransferableAccount;\n        case ExtensionType.TransferHook:\n            return ExtensionType.TransferHookAccount;\n        case ExtensionType.PausableConfig:\n            return ExtensionType.PausableAccount;\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.Uninitialized:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableAccount:\n            return ExtensionType.Uninitialized;\n    }\n}\n\nfunction getLen(\n    extensionTypes: ExtensionType[],\n    baseSize: number,\n    variableLengthExtensions: { [E in ExtensionType]?: number } = {},\n): number {\n    if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {\n        return baseSize;\n    } else {\n        const accountLength =\n            ACCOUNT_SIZE +\n            ACCOUNT_TYPE_SIZE +\n            extensionTypes\n                .filter((element, i) => i === extensionTypes.indexOf(element))\n                .map(element => addTypeAndLengthToLen(getTypeLen(element)))\n                .reduce((a, b) => a + b, 0) +\n            Object.entries(variableLengthExtensions)\n                .map(([extension, len]) => {\n                    if (!isVariableLengthExtension(Number(extension))) {\n                        throw Error(`Extension ${extension} is not variable length`);\n                    }\n                    return addTypeAndLengthToLen(len);\n                })\n                .reduce((a, b) => a + b, 0);\n        if (accountLength === MULTISIG_SIZE) {\n            return accountLength + TYPE_SIZE;\n        } else {\n            return accountLength;\n        }\n    }\n}\n\nexport function getMintLen(\n    extensionTypes: ExtensionType[],\n    variableLengthExtensions: { [E in ExtensionType]?: number } = {},\n): number {\n    return getLen(extensionTypes, MINT_SIZE, variableLengthExtensions);\n}\n\nexport function getAccountLen(extensionTypes: ExtensionType[]): number {\n    // There are currently no variable length extensions for accounts\n    return getLen(extensionTypes, ACCOUNT_SIZE);\n}\n\nexport function getExtensionData(extension: ExtensionType, tlvData: Buffer): Buffer | null {\n    let extensionTypeIndex = 0;\n    while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {\n        const entryType = tlvData.readUInt16LE(extensionTypeIndex);\n        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);\n        const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);\n        if (entryType == extension) {\n            return tlvData.slice(typeIndex, typeIndex + entryLength);\n        }\n        extensionTypeIndex = typeIndex + entryLength;\n    }\n    return null;\n}\n\nexport function getExtensionTypes(tlvData: Buffer): ExtensionType[] {\n    const extensionTypes = [];\n    let extensionTypeIndex = 0;\n    while (extensionTypeIndex < tlvData.length) {\n        const entryType = tlvData.readUInt16LE(extensionTypeIndex);\n        extensionTypes.push(entryType);\n        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);\n        extensionTypeIndex += addTypeAndLengthToLen(entryLength);\n    }\n    return extensionTypes;\n}\n\nexport function getAccountLenForMint(mint: Mint): number {\n    const extensionTypes = getExtensionTypes(mint.tlvData);\n    const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);\n    return getAccountLen(accountExtensions);\n}\n\nexport function getNewAccountLenForExtensionLen(\n    info: AccountInfo<Buffer>,\n    address: PublicKey,\n    extensionType: ExtensionType,\n    extensionLen: number,\n    programId = TOKEN_2022_PROGRAM_ID,\n): number {\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(extensionType, mint.tlvData);\n\n    const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;\n    const newExtensionLen = addTypeAndLengthToLen(extensionLen);\n\n    return info.data.length + newExtensionLen - currentExtensionLen;\n}\n", "import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n} from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n\n/** Information about a token account */\nexport interface Account {\n    /** Address of the account */\n    address: PublicKey;\n    /** Mint associated with the account */\n    mint: PublicKey;\n    /** Owner of the account */\n    owner: PublicKey;\n    /** Number of tokens the account holds */\n    amount: bigint;\n    /** Authority that can transfer tokens from the account */\n    delegate: PublicKey | null;\n    /** Number of tokens the delegate is authorized to transfer */\n    delegatedAmount: bigint;\n    /** True if the account is initialized */\n    isInitialized: boolean;\n    /** True if the account is frozen */\n    isFrozen: boolean;\n    /** True if the account is a native token account */\n    isNative: boolean;\n    /**\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\n     * remain in the balance until the account is closed.\n     */\n    rentExemptReserve: bigint | null;\n    /** Optional authority to close the account */\n    closeAuthority: PublicKey | null;\n    tlvData: Buffer;\n}\n\n/** Token account state as stored by the program */\nexport enum AccountState {\n    Uninitialized = 0,\n    Initialized = 1,\n    Frozen = 2,\n}\n\n/** Token account as stored by the program */\nexport interface RawAccount {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: bigint;\n    delegateOption: 1 | 0;\n    delegate: PublicKey;\n    state: AccountState;\n    isNativeOption: 1 | 0;\n    isNative: bigint;\n    delegatedAmount: bigint;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct<RawAccount>([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Account> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackAccount(address, info, programId);\n}\n\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getMultipleAccounts(\n    connection: Connection,\n    addresses: PublicKey[],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Account[]> {\n    const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(\n    connection: Connection,\n    commitment?: Commitment,\n): Promise<number> {\n    return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(\n    connection: Connection,\n    extensions: ExtensionType[],\n    commitment?: Commitment,\n): Promise<number> {\n    const accountLen = getAccountLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nexport function unpackAccount(\n    address: PublicKey,\n    info: AccountInfo<Buffer> | null,\n    programId = TOKEN_PROGRAM_ID,\n): Account {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > ACCOUNT_SIZE) {\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Account) throw new TokenInvalidAccountError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n        tlvData,\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\n\n/** Information about a multisig */\nexport interface Multisig {\n    /** Address of the multisig */\n    address: PublicKey;\n    /** Number of signers required */\n    m: number;\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\n    n: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Full set of signers, of which `n` are valid */\n    signer1: PublicKey;\n    signer2: PublicKey;\n    signer3: PublicKey;\n    signer4: PublicKey;\n    signer5: PublicKey;\n    signer6: PublicKey;\n    signer7: PublicKey;\n    signer8: PublicKey;\n    signer9: PublicKey;\n    signer10: PublicKey;\n    signer11: PublicKey;\n}\n\n/** Multisig as stored by the program */\nexport type RawMultisig = Omit<Multisig, 'address'>;\n\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct<RawMultisig>([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Multisig> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMultisig(address, info, programId);\n}\n\n/**\n * Unpack a multisig\n *\n * @param address   Multisig account\n * @param info      Multisig account data\n * @param programId SPL Token program account\n *\n * @return Unpacked multisig\n */\nexport function unpackMultisig(\n    address: PublicKey,\n    info: AccountInfo<Buffer> | null,\n    programId = TOKEN_PROGRAM_ID,\n): Multisig {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const multisig = MultisigLayout.decode(info.data);\n\n    return { address, ...multisig };\n}\n\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(\n    connection: Connection,\n    commitment?: Commitment,\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createDisableCpiGuardInstruction, createEnableCpiGuardInstruction } from './instructions.js';\n\n/**\n * Enable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableCpiGuard(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createEnableCpiGuardInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Disable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableCpiGuard(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createDisableCpiGuardInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import type { Signer } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\n/** @internal */\nexport function getSigners(signerOrMultisig: Signer | PublicKey, multiSigners: Signer[]): [PublicKey, Signer[]] {\n    return signerOrMultisig instanceof PublicKey\n        ? [signerOrMultisig, multiSigners]\n        : [signerOrMultisig.publicKey, [signerOrMultisig]];\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum CpiGuardInstruction {\n    Enable = 0,\n    Disable = 1,\n}\n\n/** TODO: docs */\nexport interface CpiGuardInstructionData {\n    instruction: TokenInstruction.CpiGuardExtension;\n    cpiGuardInstruction: CpiGuardInstruction;\n}\n\n/** TODO: docs */\nexport const cpiGuardInstructionData = struct<CpiGuardInstructionData>([u8('instruction'), u8('cpiGuardInstruction')]);\n\n/**\n * Construct an EnableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableCpiGuardInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);\n}\n\n/**\n * Construct a DisableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableCpiGuardInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);\n}\n\nfunction createCpiGuardInstruction(\n    cpiGuardInstruction: CpiGuardInstruction,\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(cpiGuardInstructionData.span);\n    cpiGuardInstructionData.encode(\n        {\n            instruction: TokenInstruction.CpiGuardExtension,\n            cpiGuardInstruction,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\n/** @internal */\nexport function addSigners(\n    keys: AccountMeta[],\n    ownerOrAuthority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n): AccountMeta[] {\n    if (multiSigners.length) {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });\n        for (const signer of multiSigners) {\n            keys.push({\n                pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n                isSigner: true,\n                isWritable: false,\n            });\n        }\n    } else {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });\n    }\n    return keys;\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { bool } from '@solana/buffer-layout-utils';\nimport type { Account } from '../../state/account.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** CpiGuard as stored by the program */\nexport interface CpiGuard {\n    /** Lock certain token operations from taking place within CPI for this account */\n    lockCpi: boolean;\n}\n\n/** Buffer layout for de/serializing a CPI Guard extension */\nexport const CpiGuardLayout = struct<CpiGuard>([bool('lockCpi')]);\n\nexport const CPI_GUARD_SIZE = CpiGuardLayout.span;\n\nexport function getCpiGuard(account: Account): CpiGuard | null {\n    const extensionData = getExtensionData(ExtensionType.CpiGuard, account.tlvData);\n    if (extensionData !== null) {\n        return CpiGuardLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport type { AccountState } from '../../state/account.js';\nimport {\n    createInitializeDefaultAccountStateInstruction,\n    createUpdateDefaultAccountStateInstruction,\n} from './instructions.js';\n\n/**\n * Initialize a default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to initialize with extension\n * @param state        Account state with which to initialize new accounts\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeDefaultAccountState(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    state: AccountState,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createInitializeDefaultAccountStateInstruction(mint, state, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update the default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to modify\n * @param state        New account state to set on created accounts\n * @param freezeAuthority          Freeze authority of the mint\n * @param multiSigners   Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateDefaultAccountState(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    state: AccountState,\n    freezeAuthority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [freezeAuthorityPublicKey, signers] = getSigners(freezeAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateDefaultAccountStateInstruction(mint, state, freezeAuthorityPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport type { AccountState } from '../../state/account.js';\n\nexport enum DefaultAccountStateInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** TODO: docs */\nexport interface DefaultAccountStateInstructionData {\n    instruction: TokenInstruction.DefaultAccountStateExtension;\n    defaultAccountStateInstruction: DefaultAccountStateInstruction;\n    accountState: AccountState;\n}\n\n/** TODO: docs */\nexport const defaultAccountStateInstructionData = struct<DefaultAccountStateInstructionData>([\n    u8('instruction'),\n    u8('defaultAccountStateInstruction'),\n    u8('accountState'),\n]);\n\n/**\n * Construct an InitializeDefaultAccountState instruction\n *\n * @param mint         Mint to initialize\n * @param accountState Default account state to set on all new accounts\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeDefaultAccountStateInstruction(\n    mint: PublicKey,\n    accountState: AccountState,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode(\n        {\n            instruction: TokenInstruction.DefaultAccountStateExtension,\n            defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,\n            accountState,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Construct an UpdateDefaultAccountState instruction\n *\n * @param mint         Mint to update\n * @param accountState    Default account state to set on all accounts\n * @param freezeAuthority       The mint's freeze authority\n * @param signers         The signer account(s) for a multisig\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateDefaultAccountStateInstruction(\n    mint: PublicKey,\n    accountState: AccountState,\n    freezeAuthority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode(\n        {\n            instruction: TokenInstruction.DefaultAccountStateExtension,\n            defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,\n            accountState,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountState } from '../../state/account.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** DefaultAccountState as stored by the program */\nexport interface DefaultAccountState {\n    /** Default AccountState in which new accounts are initialized */\n    state: AccountState;\n}\n\n/** Buffer layout for de/serializing a transfer fee config extension */\nexport const DefaultAccountStateLayout = struct<DefaultAccountState>([u8('state')]);\n\nexport const DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;\n\nexport function getDefaultAccountState(mint: Mint): DefaultAccountState | null {\n    const extensionData = getExtensionData(ExtensionType.DefaultAccountState, mint.tlvData);\n    if (extensionData !== null) {\n        return DefaultAccountStateLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "export * from './actions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport {\n    createInitializeGroupInstruction,\n    createUpdateGroupMaxSizeInstruction,\n    createUpdateGroupAuthorityInstruction,\n    createInitializeMemberInstruction,\n    TOKEN_GROUP_SIZE,\n    TOKEN_GROUP_MEMBER_SIZE,\n} from '@solana/spl-token-group';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\n\n/**\n * Initialize a new `Group`\n *\n * Assumes one has already initialized a mint for the group.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param mintAuthority    Group mint authority\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupInitializeGroup(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    updateAuthority: PublicKey | null,\n    maxSize: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeGroupInstruction({\n            programId,\n            group: mint,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            updateAuthority,\n            maxSize,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initialize a new `Group` with rent transfer.\n *\n * Assumes one has already initialized a mint for the group.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param mintAuthority    Group mint authority\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupInitializeGroupWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    updateAuthority: PublicKey | null,\n    maxSize: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_SIZE);\n\n    const transaction = new Transaction().add(\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: mint,\n            lamports,\n        }),\n        createInitializeGroupInstruction({\n            programId,\n            group: mint,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            updateAuthority,\n            maxSize,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Update the max size of a `Group`\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupUpdateGroupMaxSize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    maxSize: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateGroupMaxSizeInstruction({\n            programId,\n            group: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            maxSize,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Update the authority of a `Group`\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param updateAuthority  Group update authority\n * @param newAuthority     New authority for the token group, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupUpdateGroupAuthority(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateGroupAuthorityInstruction({\n            programId,\n            group: mint,\n            currentAuthority: updateAuthorityPublicKey,\n            newAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initialize a new `Member` of a `Group`\n *\n * Assumes the `Group` has already been initialized,\n * as well as the mint for the member.\n *\n * @param connection             Connection to use\n * @param payer                  Payer of the transaction fee\n * @param mint                   Member mint\n * @param mintAuthority          Member mint authority\n * @param group                  Group mint\n * @param groupUpdateAuthority   Group update authority\n * @param multiSigners           Signing accounts if `authority` is a multisig\n * @param confirmOptions         Options for confirming the transaction\n * @param programId              SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupMemberInitialize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    group: PublicKey,\n    groupUpdateAuthority: PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeMemberInstruction({\n            programId,\n            member: mint,\n            memberMint: mint,\n            memberMintAuthority: mintAuthorityPublicKey,\n            group,\n            groupUpdateAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initialize a new `Member` of a `Group` with rent transfer.\n *\n * Assumes the `Group` has already been initialized,\n * as well as the mint for the member.\n *\n * @param connection             Connection to use\n * @param payer                  Payer of the transaction fee\n * @param mint                   Member mint\n * @param mintAuthority          Member mint authority\n * @param group                  Group mint\n * @param groupUpdateAuthority   Group update authority\n * @param multiSigners           Signing accounts if `authority` is a multisig\n * @param confirmOptions         Options for confirming the transaction\n * @param programId              SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupMemberInitializeWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    group: PublicKey,\n    groupUpdateAuthority: PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_MEMBER_SIZE);\n\n    const transaction = new Transaction().add(\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: mint,\n            lamports,\n        }),\n        createInitializeMemberInstruction({\n            programId,\n            member: mint,\n            memberMint: mint,\n            memberMintAuthority: mintAuthorityPublicKey,\n            group,\n            groupUpdateAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "export * from './errors.js';\nexport * from './instruction.js';\nexport * from './state/index.js';\n", "export class TokenGroupError extends Error {\n    constructor(message?: string) {\n        super(message);\n    }\n}\n\n/** Thrown if size is greater than proposed max size */\nexport class SizeExceedsNewMaxSizeError extends TokenGroupError {\n    name = 'SizeExceedsNewMaxSizeError';\n}\n\n/** Thrown if size is greater than max size */\nexport class SizeExceedsMaxSizeError extends TokenGroupError {\n    name = 'SizeExceedsMaxSizeError';\n}\n\n/** Thrown if group is immutable */\nexport class ImmutableGroupError extends TokenGroupError {\n    name = 'ImmutableGroupError';\n}\n\n/** Thrown if incorrect mint authority has signed the instruction */\nexport class IncorrectMintAuthorityError extends TokenGroupError {\n    name = 'IncorrectMintAuthorityError';\n}\n\n/** Thrown if incorrect update authority has signed the instruction */\nexport class IncorrectUpdateAuthorityError extends TokenGroupError {\n    name = 'IncorrectUpdateAuthorityError';\n}\n\n/** Thrown if member account is the same as the group account */\nexport class MemberAccountIsGroupAccountError extends TokenGroupError {\n    name = 'MemberAccountIsGroupAccountError';\n}\n", "import type { Encoder } from '@solana/codecs';\nimport type { PublicKey } from '@solana/web3.js';\nimport {\n    fixEncoderSize,\n    getBytesEncoder,\n    getStructEncoder,\n    getTupleEncoder,\n    getU64Encoder,\n    transformEncoder,\n} from '@solana/codecs';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\n\nfunction getInstructionEncoder<T extends object>(discriminator: Uint8Array, dataEncoder: Encoder<T>): Encoder<T> {\n    return transformEncoder(getTupleEncoder([getBytesEncoder(), dataEncoder]), (data: T): [Uint8Array, T] => [\n        discriminator,\n        data,\n    ]);\n}\n\nfunction getPublicKeyEncoder(): Encoder<PublicKey> {\n    return transformEncoder(fixEncoderSize(getBytesEncoder(), 32), (publicKey: PublicKey) => publicKey.toBytes());\n}\n\nexport interface InitializeGroupInstruction {\n    programId: PublicKey;\n    group: PublicKey;\n    mint: PublicKey;\n    mintAuthority: PublicKey;\n    updateAuthority: PublicKey | null;\n    maxSize: bigint;\n}\n\nexport function createInitializeGroupInstruction(args: InitializeGroupInstruction): TransactionInstruction {\n    const { programId, group, mint, mintAuthority, updateAuthority, maxSize } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: false, isWritable: false, pubkey: mint },\n            { isSigner: true, isWritable: false, pubkey: mintAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:initialize_token_group') */\n                    121, 113, 108, 39, 54, 51, 0, 4,\n                ]),\n                getStructEncoder([\n                    ['updateAuthority', getPublicKeyEncoder()],\n                    ['maxSize', getU64Encoder()],\n                ]),\n            ).encode({ updateAuthority: updateAuthority ?? SystemProgram.programId, maxSize }),\n        ),\n    });\n}\n\nexport interface UpdateGroupMaxSize {\n    programId: PublicKey;\n    group: PublicKey;\n    updateAuthority: PublicKey;\n    maxSize: bigint;\n}\n\nexport function createUpdateGroupMaxSizeInstruction(args: UpdateGroupMaxSize): TransactionInstruction {\n    const { programId, group, updateAuthority, maxSize } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:update_group_max_size') */\n                    108, 37, 171, 143, 248, 30, 18, 110,\n                ]),\n                getStructEncoder([['maxSize', getU64Encoder()]]),\n            ).encode({ maxSize }),\n        ),\n    });\n}\n\nexport interface UpdateGroupAuthority {\n    programId: PublicKey;\n    group: PublicKey;\n    currentAuthority: PublicKey;\n    newAuthority: PublicKey | null;\n}\n\nexport function createUpdateGroupAuthorityInstruction(args: UpdateGroupAuthority): TransactionInstruction {\n    const { programId, group, currentAuthority, newAuthority } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: currentAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:update_authority') */\n                    161, 105, 88, 1, 237, 221, 216, 203,\n                ]),\n                getStructEncoder([['newAuthority', getPublicKeyEncoder()]]),\n            ).encode({ newAuthority: newAuthority ?? SystemProgram.programId }),\n        ),\n    });\n}\n\nexport interface InitializeMember {\n    programId: PublicKey;\n    member: PublicKey;\n    memberMint: PublicKey;\n    memberMintAuthority: PublicKey;\n    group: PublicKey;\n    groupUpdateAuthority: PublicKey;\n}\n\nexport function createInitializeMemberInstruction(args: InitializeMember): TransactionInstruction {\n    const { programId, member, memberMint, memberMintAuthority, group, groupUpdateAuthority } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: member },\n            { isSigner: false, isWritable: false, pubkey: memberMint },\n            { isSigner: true, isWritable: false, pubkey: memberMintAuthority },\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: groupUpdateAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:initialize_member') */\n                    152, 32, 222, 176, 223, 237, 116, 134,\n                ]),\n                getStructEncoder([]),\n            ).encode({}),\n        ),\n    });\n}\n", "export * from './tokenGroup.js';\nexport * from './tokenGroupMember.js';\n", "import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['size', getU64Codec()],\n    ['maxSize', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n\nexport interface TokenGroup {\n    /** The authority that can sign to update the group */\n    updateAuthority?: PublicKey;\n    /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint */\n    mint: PublicKey;\n    /** The current number of group members */\n    size: bigint;\n    /** The maximum number of group members */\n    maxSize: bigint;\n}\n\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group: TokenGroup): ReadonlyUint8Array {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = group.updateAuthority ?? PublicKey.default;\n    return tokenGroupCodec.encode({\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: group.mint.toBuffer(),\n        size: group.size,\n        maxSize: group.maxSize,\n    });\n}\n\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroup {\n    const data = tokenGroupCodec.decode(buffer);\n\n    return isNonePubkey(data.updateAuthority)\n        ? {\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          }\n        : {\n              updateAuthority: new PublicKey(data.updateAuthority),\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          };\n}\n", "import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupMemberCodec = getStructCodec([\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['group', fixCodecSize(getBytesCodec(), 32)],\n    ['memberNumber', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize;\n\nexport interface TokenGroupMember {\n    /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint */\n    mint: PublicKey;\n    /** The pubkey of the `TokenGroup` */\n    group: PublicKey;\n    /** The member number */\n    memberNumber: bigint;\n}\n\n// Pack TokenGroupMember into byte slab\nexport function packTokenGroupMember(member: TokenGroupMember): ReadonlyUint8Array {\n    return tokenGroupMemberCodec.encode({\n        mint: member.mint.toBuffer(),\n        group: member.group.toBuffer(),\n        memberNumber: member.memberNumber,\n    });\n}\n\n// unpack byte slab into TokenGroupMember\nexport function unpackTokenGroupMember(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroupMember {\n    const data = tokenGroupMemberCodec.decode(buffer);\n    return {\n        mint: new PublicKey(data.mint),\n        group: new PublicKey(data.group),\n        memberNumber: data.memberNumber,\n    };\n}\n", "import { struct, u32 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport {\n    unpackTokenGroup,\n    unpackTokenGroupMember,\n    type TokenGroup,\n    type TokenGroupMember,\n} from '@solana/spl-token-group';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport { TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE } from '@solana/spl-token-group';\n\nexport function getTokenGroupState(mint: Mint): Partial<TokenGroup> | null {\n    const extensionData = getExtensionData(ExtensionType.TokenGroup, mint.tlvData);\n    if (extensionData !== null) {\n        const { updateAuthority, mint, size, maxSize } = unpackTokenGroup(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            updateAuthority: updateAuthority?.equals(PublicKey.default) ? undefined : updateAuthority,\n            mint,\n            size,\n            maxSize,\n        };\n    } else {\n        return null;\n    }\n}\n\nexport function getTokenGroupMemberState(mint: Mint): Partial<TokenGroupMember> | null {\n    const extensionData = getExtensionData(ExtensionType.TokenGroupMember, mint.tlvData);\n    if (extensionData !== null) {\n        const { mint, group, memberNumber } = unpackTokenGroupMember(extensionData);\n\n        return {\n            mint,\n            group,\n            memberNumber,\n        };\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** GroupMemberPointer as stored by the program */\nexport interface GroupMemberPointer {\n    /** Optional authority that can set the member address */\n    authority: PublicKey | null;\n    /** Optional account address that holds the member */\n    memberAddress: PublicKey | null;\n}\n\n/** Buffer layout for de/serializing a Group Pointer extension */\nexport const GroupMemberPointerLayout = struct<{ authority: PublicKey; memberAddress: PublicKey }>([\n    publicKey('authority'),\n    publicKey('memberAddress'),\n]);\n\nexport const GROUP_MEMBER_POINTER_SIZE = GroupMemberPointerLayout.span;\n\nexport function getGroupMemberPointerState(mint: Mint): Partial<GroupMemberPointer> | null {\n    const extensionData = getExtensionData(ExtensionType.GroupMemberPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, memberAddress } = GroupMemberPointerLayout.decode(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            memberAddress: memberAddress.equals(PublicKey.default) ? null : memberAddress,\n        };\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** GroupPointer as stored by the program */\nexport interface GroupPointer {\n    /** Optional authority that can set the group address */\n    authority: PublicKey | null;\n    /** Optional account address that holds the group */\n    groupAddress: PublicKey | null;\n}\n\n/** Buffer layout for de/serializing a GroupPointer extension */\nexport const GroupPointerLayout = struct<{ authority: PublicKey; groupAddress: PublicKey }>([\n    publicKey('authority'),\n    publicKey('groupAddress'),\n]);\n\nexport const GROUP_POINTER_SIZE = GroupPointerLayout.span;\n\nexport function getGroupPointerState(mint: Mint): Partial<GroupPointer> | null {\n    const extensionData = getExtensionData(ExtensionType.GroupPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, groupAddress } = GroupPointerLayout.decode(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            groupAddress: groupAddress.equals(PublicKey.default) ? null : groupAddress,\n        };\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport type { Account } from '../state/account.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** ImmutableOwner as stored by the program */\nexport interface ImmutableOwner {} // eslint-disable-line\n\n/** Buffer layout for de/serializing an account */\nexport const ImmutableOwnerLayout = struct<ImmutableOwner>([]);\n\nexport const IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span;\n\nexport function getImmutableOwner(account: Account): ImmutableOwner | null {\n    const extensionData = getExtensionData(ExtensionType.ImmutableOwner, account.tlvData);\n    if (extensionData !== null) {\n        return ImmutableOwnerLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "import { ns64, s16, struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport interface InterestBearingMintConfigState {\n    rateAuthority: PublicKey;\n    initializationTimestamp: bigint;\n    preUpdateAverageRate: number;\n    lastUpdateTimestamp: bigint;\n    currentRate: number;\n}\n\nexport const InterestBearingMintConfigStateLayout = struct<InterestBearingMintConfigState>([\n    publicKey('rateAuthority'),\n    ns64('initializationTimestamp'),\n    s16('preUpdateAverageRate'),\n    ns64('lastUpdateTimestamp'),\n    s16('currentRate'),\n]);\n\nexport const INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span;\n\nexport function getInterestBearingMintConfigState(mint: Mint): InterestBearingMintConfigState | null {\n    const extensionData = getExtensionData(ExtensionType.InterestBearingConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return InterestBearingMintConfigStateLayout.decode(extensionData);\n    }\n    return null;\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    createDisableRequiredMemoTransfersInstruction,\n    createEnableRequiredMemoTransfersInstruction,\n} from './instructions.js';\n\n/**\n * Enable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableRequiredMemoTransfers(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createEnableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Disable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableRequiredMemoTransfers(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createDisableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum MemoTransferInstruction {\n    Enable = 0,\n    Disable = 1,\n}\n\n/** TODO: docs */\nexport interface MemoTransferInstructionData {\n    instruction: TokenInstruction.MemoTransferExtension;\n    memoTransferInstruction: MemoTransferInstruction;\n}\n\n/** TODO: docs */\nexport const memoTransferInstructionData = struct<MemoTransferInstructionData>([\n    u8('instruction'),\n    u8('memoTransferInstruction'),\n]);\n\n/**\n * Construct an EnableRequiredMemoTransfers instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableRequiredMemoTransfersInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);\n}\n\n/**\n * Construct a DisableMemoTransfer instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableRequiredMemoTransfersInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);\n}\n\nfunction createMemoTransferInstruction(\n    memoTransferInstruction: MemoTransferInstruction,\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(memoTransferInstructionData.span);\n    memoTransferInstructionData.encode(\n        {\n            instruction: TokenInstruction.MemoTransferExtension,\n            memoTransferInstruction,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { bool } from '@solana/buffer-layout-utils';\nimport type { Account } from '../../state/account.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** MemoTransfer as stored by the program */\nexport interface MemoTransfer {\n    /** Require transfers into this account to be accompanied by a memo */\n    requireIncomingTransferMemos: boolean;\n}\n\n/** Buffer layout for de/serializing a memo transfer extension */\nexport const MemoTransferLayout = struct<MemoTransfer>([bool('requireIncomingTransferMemos')]);\n\nexport const MEMO_TRANSFER_SIZE = MemoTransferLayout.span;\n\nexport function getMemoTransfer(account: Account): MemoTransfer | null {\n    const extensionData = getExtensionData(ExtensionType.MemoTransfer, account.tlvData);\n    if (extensionData !== null) {\n        return MemoTransferLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** MetadataPointer as stored by the program */\nexport interface MetadataPointer {\n    /** Optional authority that can set the metadata address */\n    authority: PublicKey | null;\n    /** Optional Account Address that holds the metadata */\n    metadataAddress: PublicKey | null;\n}\n\n/** Buffer layout for de/serializing a Metadata Pointer extension */\nexport const MetadataPointerLayout = struct<{ authority: PublicKey; metadataAddress: PublicKey }>([\n    publicKey('authority'),\n    publicKey('metadataAddress'),\n]);\n\nexport const METADATA_POINTER_SIZE = MetadataPointerLayout.span;\n\nexport function getMetadataPointerState(mint: Mint): Partial<MetadataPointer> | null {\n    const extensionData = getExtensionData(ExtensionType.MetadataPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, metadataAddress } = MetadataPointerLayout.decode(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            metadataAddress: metadataAddress.equals(PublicKey.default) ? null : metadataAddress,\n        };\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../state/mint.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** MintCloseAuthority as stored by the program */\nexport interface MintCloseAuthority {\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintCloseAuthorityLayout = struct<MintCloseAuthority>([publicKey('closeAuthority')]);\n\nexport const MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span;\n\nexport function getMintCloseAuthority(mint: Mint): MintCloseAuthority | null {\n    const extensionData = getExtensionData(ExtensionType.MintCloseAuthority, mint.tlvData);\n    if (extensionData !== null) {\n        return MintCloseAuthorityLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport type { Account } from '../state/account.js';\nimport type { Mint } from '../state/mint.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** Non-transferable mint state as stored by the program */\nexport interface NonTransferable {} // eslint-disable-line\n\n/** Non-transferable token account state as stored by the program */\nexport interface NonTransferableAccount {} // eslint-disable-line\n\n/** Buffer layout for de/serializing an account */\nexport const NonTransferableLayout = struct<NonTransferable>([]);\n\nexport const NON_TRANSFERABLE_SIZE = NonTransferableLayout.span;\nexport const NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span;\n\nexport function getNonTransferable(mint: Mint): NonTransferable | null {\n    const extensionData = getExtensionData(ExtensionType.NonTransferable, mint.tlvData);\n    if (extensionData !== null) {\n        return NonTransferableLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\nexport function getNonTransferableAccount(account: Account): NonTransferableAccount | null {\n    const extensionData = getExtensionData(ExtensionType.NonTransferableAccount, account.tlvData);\n    if (extensionData !== null) {\n        return NonTransferableLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createPauseInstruction, createResumeInstruction } from './instructions.js';\n\n/**\n * Pause a pausable mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param owner           The pausable config authority\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function pause(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(createPauseInstruction(mint, ownerPublicKey, multiSigners, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Resume a pausable mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param owner           The pausable config authority\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function resume(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(createResumeInstruction(mint, ownerPublicKey, multiSigners, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum PausableInstruction {\n    Initialize = 0,\n    Pause = 1,\n    Resume = 2,\n}\n\nexport interface InitializePausableConfigInstructionData {\n    instruction: TokenInstruction.PausableExtension;\n    pausableInstruction: PausableInstruction.Initialize;\n    authority: PublicKey;\n}\n\nexport const initializePausableConfigInstructionData = struct<InitializePausableConfigInstructionData>([\n    u8('instruction'),\n    u8('pausableInstruction'),\n    publicKey('authority'),\n]);\n\n/**\n * Construct a InitializePausableConfig instruction\n *\n * @param mint          Token mint account\n * @param authority     Optional authority that can pause or resume mint\n * @param programId     SPL Token program account\n */\nexport function createInitializePausableConfigInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializePausableConfigInstructionData.span);\n    initializePausableConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.PausableExtension,\n            pausableInstruction: PausableInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport interface PauseInstructionData {\n    instruction: TokenInstruction.PausableExtension;\n    pausableInstruction: PausableInstruction.Pause;\n}\n\nexport const pauseInstructionData = struct<PauseInstructionData>([u8('instruction'), u8('pausableInstruction')]);\n\n/**\n * Construct a Pause instruction\n *\n * @param mint          Token mint account\n * @param authority     The pausable mint's authority\n * @param multiSigners  Signing accounts if authority is a multisig\n * @param programId     SPL Token program account\n */\nexport function createPauseInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(pauseInstructionData.span);\n    pauseInstructionData.encode(\n        {\n            instruction: TokenInstruction.PausableExtension,\n            pausableInstruction: PausableInstruction.Pause,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport interface ResumeInstructionData {\n    instruction: TokenInstruction.PausableExtension;\n    pausableInstruction: PausableInstruction.Resume;\n}\n\nexport const resumeInstructionData = struct<ResumeInstructionData>([u8('instruction'), u8('pausableInstruction')]);\n\n/**\n * Construct a Resume instruction\n *\n * @param mint          Token mint account\n * @param authority     The pausable mint's authority\n * @param multiSigners  Signing accounts if authority is a multisig\n * @param programId     SPL Token program account\n */\nexport function createResumeInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(resumeInstructionData.span);\n    resumeInstructionData.encode(\n        {\n            instruction: TokenInstruction.PausableExtension,\n            pausableInstruction: PausableInstruction.Resume,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { publicKey, bool } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Account } from '../../state/account.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** PausableConfig as stored by the program */\nexport interface PausableConfig {\n    /** Authority that can pause or resume activity on the mint */\n    authority: PublicKey;\n    /** Whether minting / transferring / burning tokens is paused */\n    paused: boolean;\n}\n\n/** Buffer layout for de/serializing a pausable config */\nexport const PausableConfigLayout = struct<PausableConfig>([publicKey('authority'), bool('paused')]);\n\nexport const PAUSABLE_CONFIG_SIZE = PausableConfigLayout.span;\n\nexport function getPausableConfig(mint: Mint): PausableConfig | null {\n    const extensionData = getExtensionData(ExtensionType.PausableConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return PausableConfigLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\n/** Pausable token account state as stored by the program */\nexport interface PausableAccount {} // eslint-disable-line\n\n/** Buffer layout for de/serializing a pausable account */\nexport const PausableAccountLayout = struct<PausableAccount>([]); // esline-disable-line\n\nexport const PAUSABLE_ACCOUNT_SIZE = PausableAccountLayout.span;\n\nexport function getPausableAccount(account: Account): PausableAccount | null {\n    const extensionData = getExtensionData(ExtensionType.PausableAccount, account.tlvData);\n    if (extensionData !== null) {\n        return PausableAccountLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../state/mint.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** PermanentDelegate as stored by the program */\nexport interface PermanentDelegate {\n    delegate: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const PermanentDelegateLayout = struct<PermanentDelegate>([publicKey('delegate')]);\n\nexport const PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span;\n\nexport function getPermanentDelegate(mint: Mint): PermanentDelegate | null {\n    const extensionData = getExtensionData(ExtensionType.PermanentDelegate, mint.tlvData);\n    if (extensionData !== null) {\n        return PermanentDelegateLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createUpdateMultiplierDataInstruction } from './instructions.js';\n\n/**\n * Update scaled UI amount multiplier\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  The token mint\n * @param owner                 Owner of the scaled UI amount mint\n * @param multiplier            New multiplier\n * @param effectiveTimestamp    Effective time stamp for the new multiplier\n * @param multiSigners          Signing accounts if `owner` is a multisig\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateMultiplier(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    multiplier: number,\n    effectiveTimestamp: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateMultiplierDataInstruction(\n            mint,\n            ownerPublicKey,\n            multiplier,\n            effectiveTimestamp,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8, f64 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport type { Signer } from '@solana/web3.js';\nimport { TransactionInstruction, PublicKey } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum ScaledUiAmountInstruction {\n    Initialize = 0,\n    UpdateMultiplier = 1,\n}\n\nexport interface InitializeScaledUiAmountConfigData {\n    instruction: TokenInstruction.ScaledUiAmountExtension;\n    scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize;\n    authority: PublicKey | null;\n    multiplier: number;\n}\n\nexport const initializeScaledUiAmountConfigInstructionData = struct<InitializeScaledUiAmountConfigData>([\n    u8('instruction'),\n    u8('scaledUiAmountInstruction'),\n    publicKey('authority'),\n    f64('multiplier'),\n]);\n\n/**\n * Construct an InitializeScaledUiAmountConfig instruction\n *\n * @param mint         Token mint account\n * @param authority    Optional authority that can update the multipliers\n * @param signers      The signer account(s)\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeScaledUiAmountConfigInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    multiplier: number,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeScaledUiAmountConfigInstructionData.span);\n    initializeScaledUiAmountConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.ScaledUiAmountExtension,\n            scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            multiplier: multiplier,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nexport interface UpdateMultiplierData {\n    instruction: TokenInstruction.ScaledUiAmountExtension;\n    scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier;\n    multiplier: number;\n    effectiveTimestamp: bigint;\n}\n\nexport const updateMultiplierData = struct<UpdateMultiplierData>([\n    u8('instruction'),\n    u8('scaledUiAmountInstruction'),\n    f64('multiplier'),\n    u64('effectiveTimestamp'),\n]);\n\n/**\n * Construct an UpdateMultiplierData instruction\n *\n * @param mint                  Token mint account\n * @param authority             Optional authority that can update the multipliers\n * @param multiplier            New multiplier\n * @param effectiveTimestamp    Effective time stamp for the new multiplier\n * @param multiSigners          Signing accounts if `owner` is a multisig\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateMultiplierDataInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    multiplier: number,\n    effectiveTimestamp: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateMultiplierData.span);\n    updateMultiplierData.encode(\n        {\n            instruction: TokenInstruction.ScaledUiAmountExtension,\n            scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier,\n            multiplier,\n            effectiveTimestamp,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import { f64, struct } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport interface ScaledUiAmountConfig {\n    authority: PublicKey;\n    multiplier: number;\n    newMultiplierEffectiveTimestamp: bigint;\n    newMultiplier: number;\n}\n\nexport const ScaledUiAmountConfigLayout = struct<ScaledUiAmountConfig>([\n    publicKey('authority'),\n    f64('multiplier'),\n    u64('newMultiplierEffectiveTimestamp'),\n    f64('newMultiplier'),\n]);\n\nexport const SCALED_UI_AMOUNT_CONFIG_SIZE = ScaledUiAmountConfigLayout.span;\n\nexport function getScaledUiAmountConfig(mint: Mint): ScaledUiAmountConfig | null {\n    const extensionData = getExtensionData(ExtensionType.ScaledUiAmountConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return ScaledUiAmountConfigLayout.decode(extensionData);\n    }\n    return null;\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    createHarvestWithheldTokensToMintInstruction,\n    createSetTransferFeeInstruction,\n    createTransferCheckedWithFeeInstruction,\n    createWithdrawWithheldTokensFromAccountsInstruction,\n    createWithdrawWithheldTokensFromMintInstruction,\n} from './instructions.js';\n\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFee(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedWithFeeInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            fee,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Withdraw withheld tokens from mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createWithdrawWithheldTokensFromMintInstruction(mint, destination, authorityPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Withdraw withheld tokens from accounts\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromAccounts(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[],\n    sources: PublicKey[],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createWithdrawWithheldTokensFromAccountsInstruction(\n            mint,\n            destination,\n            authorityPublicKey,\n            signers,\n            sources,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Harvest withheld tokens from accounts to the mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function harvestWithheldTokensToMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    sources: PublicKey[],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createHarvestWithheldTokensToMintInstruction(mint, sources, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update transfer fee and maximum fee\n *\n * @param connection                Connection to use\n * @param payer                     Payer of the transaction fees\n * @param mint                      The token mint\n * @param authority                 The authority of the transfer fee\n * @param multiSigners              Signing accounts if `owner` is a multisig\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee                Maximum fee assessed on transfers\n * @param confirmOptions            Options for confirming the transaction\n * @param programId                 SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setTransferFee(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[],\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createSetTransferFeeInstruction(\n            mint,\n            authorityPublicKey,\n            signers,\n            transferFeeBasisPoints,\n            maximumFee,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { COptionPublicKeyLayout } from '../../serialization.js';\n\nexport enum TransferFeeInstruction {\n    InitializeTransferFeeConfig = 0,\n    TransferCheckedWithFee = 1,\n    WithdrawWithheldTokensFromMint = 2,\n    WithdrawWithheldTokensFromAccounts = 3,\n    HarvestWithheldTokensToMint = 4,\n    SetTransferFee = 5,\n}\n\n// InitializeTransferFeeConfig\n\n/** TODO: docs */\nexport interface InitializeTransferFeeConfigInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n    transferFeeConfigAuthority: PublicKey | null;\n    withdrawWithheldAuthority: PublicKey | null;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct<InitializeTransferFeeConfigInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    new COptionPublicKeyLayout('transferFeeConfigAuthority'),\n    new COptionPublicKeyLayout('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(\n    mint: PublicKey,\n    transferFeeConfigAuthority: PublicKey | null,\n    withdrawWithheldAuthority: PublicKey | null,\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(78); // worst-case size\n    initializeTransferFeeConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n            transferFeeConfigAuthority: transferFeeConfigAuthority,\n            withdrawWithheldAuthority: withdrawWithheldAuthority,\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeTransferFeeConfigInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializeTransferFeeConfigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    const {\n        instruction,\n        transferFeeInstruction,\n        transferFeeConfigAuthority,\n        withdrawWithheldAuthority,\n        transferFeeBasisPoints,\n        maximumFee,\n    } = initializeTransferFeeConfigInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority,\n            withdrawWithheldAuthority,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n\n// TransferCheckedWithFee\nexport interface TransferCheckedWithFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n    amount: bigint;\n    decimals: number;\n    fee: bigint;\n}\n\nexport const transferCheckedWithFeeInstructionData = struct<TransferCheckedWithFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n            amount,\n            decimals,\n            fee,\n        },\n        data,\n    );\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferCheckedWithFee instruction */\nexport interface DecodedTransferCheckedWithFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedTransferCheckedWithFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, authority, signers },\n        data,\n    } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferCheckedWithFees instruction */\nexport interface DecodedTransferCheckedWithFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedWithFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } =\n        transferCheckedWithFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromMint\nexport interface WithdrawWithheldTokensFromMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n}\n\nexport const withdrawWithheldTokensFromMintInstructionData = struct<WithdrawWithheldTokensFromMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n        },\n        data,\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedWithdrawWithheldTokensFromMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers },\n        data,\n    } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromAccounts\nexport interface WithdrawWithheldTokensFromAccountsInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n    numTokenAccounts: number;\n}\n\nexport const withdrawWithheldTokensFromAccountsInstructionData =\n    struct<WithdrawWithheldTokensFromAccountsInstructionData>([\n        u8('instruction'),\n        u8('transferFeeInstruction'),\n        u8('numTokenAccounts'),\n    ]);\n\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[],\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n            numTokenAccounts: sources.length,\n        },\n        data,\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers,\n    );\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers, sources },\n        data,\n    } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\n    programId,\n    keys,\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    const { instruction, transferFeeInstruction, numTokenAccounts } =\n        withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\n\n// HarvestWithheldTokensToMint\n\nexport interface HarvestWithheldTokensToMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n}\n\nexport const harvestWithheldTokensToMintInstructionData = struct<HarvestWithheldTokensToMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(\n    mint: PublicKey,\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n        },\n        data,\n    );\n    const keys: AccountMeta[] = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedHarvestWithheldTokensToMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, sources },\n        data,\n    } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\n    programId,\n    keys: [mint, ...sources],\n    data,\n}: TransactionInstruction): DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// SetTransferFee\n\nexport interface SetTransferFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\nexport const setTransferFeeInstructionData = struct<SetTransferFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct a SetTransferFeeInstruction instruction\n *\n * @param mint                      The token mint\n * @param authority                 The authority of the transfer fee\n * @param signers                   The signer account(s)\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee                Maximum fee assessed on transfers\n * @param programID                 SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetTransferFeeInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[],\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const data = Buffer.alloc(setTransferFeeInstructionData.span);\n    setTransferFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.SetTransferFee,\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data,\n    );\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, signers);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SetTransferFee instruction */\nexport interface DecodedSetTransferFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an SetTransferFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetTransferFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedSetTransferFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setTransferFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, authority, signers },\n        data,\n    } = decodeSetTransferFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid SetTransferFee instruction */\nexport interface DecodedSetTransferFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode a SetTransferFee instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetTransferFeeInstructionUnchecked({\n    programId,\n    keys: [mint, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedSetTransferFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, transferFeeBasisPoints, maximumFee } =\n        setTransferFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n", "import { Layout } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\n\nexport class COptionPublicKeyLayout extends Layout<PublicKey | null> {\n    private publicKeyLayout: Layout<PublicKey>;\n\n    constructor(property?: string | undefined) {\n        super(-1, property);\n        this.publicKeyLayout = publicKey();\n    }\n\n    decode(buffer: Uint8Array, offset: number = 0): PublicKey | null {\n        const option = buffer[offset];\n        if (option === 0) {\n            return null;\n        }\n        return this.publicKeyLayout.decode(buffer, offset + 1);\n    }\n\n    encode(src: PublicKey | null, buffer: Uint8Array, offset: number = 0): number {\n        if (src === null) {\n            buffer[offset] = 0;\n            return 1;\n        } else {\n            buffer[offset] = 1;\n            this.publicKeyLayout.encode(src, buffer, offset + 1);\n            return 33;\n        }\n    }\n\n    getSpan(buffer?: Uint8Array, offset: number = 0): number {\n        if (buffer) {\n            const option = buffer[offset];\n            return option === 0 ? 1 : 1 + this.publicKeyLayout.span;\n        }\n        throw new RangeError('Buffer must be provided');\n    }\n}\n", "import type { Layout } from '@solana/buffer-layout';\nimport { struct, u16 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Account } from '../../state/account.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport const MAX_FEE_BASIS_POINTS = 10000;\nexport const ONE_IN_BASIS_POINTS = BigInt(MAX_FEE_BASIS_POINTS);\n\n/** TransferFeeConfig as stored by the program */\nexport interface TransferFee {\n    /** First epoch where the transfer fee takes effect */\n    epoch: bigint;\n    /** Maximum fee assessed on transfers, expressed as an amount of tokens */\n    maximumFee: bigint;\n    /**\n     * Amount of transfer collected as fees, expressed as basis points of the\n     * transfer amount, ie. increments of 0.01%\n     */\n    transferFeeBasisPoints: number;\n}\n\n/** Transfer fee extension data for mints. */\nexport interface TransferFeeConfig {\n    /** Optional authority to set the fee */\n    transferFeeConfigAuthority: PublicKey;\n    /** Withdraw from mint instructions must be signed by this key */\n    withdrawWithheldAuthority: PublicKey;\n    /** Withheld transfer fee tokens that have been moved to the mint for withdrawal */\n    withheldAmount: bigint;\n    /** Older transfer fee, used if the current epoch < newerTransferFee.epoch */\n    olderTransferFee: TransferFee;\n    /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch */\n    newerTransferFee: TransferFee;\n}\n\n/** Buffer layout for de/serializing a transfer fee */\nexport function transferFeeLayout(property?: string): Layout<TransferFee> {\n    return struct<TransferFee>([u64('epoch'), u64('maximumFee'), u16('transferFeeBasisPoints')], property);\n}\n\n/** Calculate the transfer fee */\nexport function calculateFee(transferFee: TransferFee, preFeeAmount: bigint): bigint {\n    const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;\n    if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {\n        return BigInt(0);\n    } else {\n        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);\n        const rawFee = (numerator + ONE_IN_BASIS_POINTS - BigInt(1)) / ONE_IN_BASIS_POINTS;\n        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;\n        return BigInt(fee);\n    }\n}\n\n/** Buffer layout for de/serializing a transfer fee config extension */\nexport const TransferFeeConfigLayout = struct<TransferFeeConfig>([\n    publicKey('transferFeeConfigAuthority'),\n    publicKey('withdrawWithheldAuthority'),\n    u64('withheldAmount'),\n    transferFeeLayout('olderTransferFee'),\n    transferFeeLayout('newerTransferFee'),\n]);\n\nexport const TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;\n\n/** Get the fee for given epoch */\nexport function getEpochFee(transferFeeConfig: TransferFeeConfig, epoch: bigint): TransferFee {\n    if (epoch >= transferFeeConfig.newerTransferFee.epoch) {\n        return transferFeeConfig.newerTransferFee;\n    } else {\n        return transferFeeConfig.olderTransferFee;\n    }\n}\n\n/** Calculate the fee for the given epoch and input amount */\nexport function calculateEpochFee(transferFeeConfig: TransferFeeConfig, epoch: bigint, preFeeAmount: bigint): bigint {\n    const transferFee = getEpochFee(transferFeeConfig, epoch);\n    return calculateFee(transferFee, preFeeAmount);\n}\n\n/** Transfer fee amount data for accounts. */\nexport interface TransferFeeAmount {\n    /** Withheld transfer fee tokens that can be claimed by the fee authority */\n    withheldAmount: bigint;\n}\n/** Buffer layout for de/serializing */\nexport const TransferFeeAmountLayout = struct<TransferFeeAmount>([u64('withheldAmount')]);\nexport const TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;\n\nexport function getTransferFeeConfig(mint: Mint): TransferFeeConfig | null {\n    const extensionData = getExtensionData(ExtensionType.TransferFeeConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return TransferFeeConfigLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\nexport function getTransferFeeAmount(account: Account): TransferFeeAmount | null {\n    const extensionData = getExtensionData(ExtensionType.TransferFeeAmount, account.tlvData);\n    if (extensionData !== null) {\n        return TransferFeeAmountLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './seeds.js';\nexport * from './state.js';\nexport * from './pubkeyData.js';\n", "import type { ConfirmOptions, Connection, Signer, TransactionSignature } from '@solana/web3.js';\nimport type { PublicKey } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport {\n    createInitializeTransferHookInstruction,\n    createTransferCheckedWithFeeAndTransferHookInstruction,\n    createTransferCheckedWithTransferHookInstruction,\n    createUpdateTransferHookInstruction,\n} from './instructions.js';\n\n/**\n * Initialize a transfer hook on a mint\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  Mint to initialize with extension\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId The transfer hook program account\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeTransferHook(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(\n        createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update the transfer hook program on a mint\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  Mint to modify\n * @param transferHookProgramId New transfer hook program account\n * @param authority             Transfer hook update authority\n * @param multiSigners          Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateTransferHook(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    transferHookProgramId: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateTransferHookInstruction(mint, authorityPublicKey, transferHookProgramId, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Transfer tokens from one account to another, asserting the token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param authority      Authority of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithTransferHook(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        await createTransferCheckedWithTransferHookInstruction(\n            connection,\n            source,\n            mint,\n            destination,\n            authorityPublicKey,\n            amount,\n            decimals,\n            signers,\n            confirmOptions?.commitment,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param authority      Authority of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param fee            The calculated fee for the transfer fee extension\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFeeAndTransferHook(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        await createTransferCheckedWithFeeAndTransferHookInstruction(\n            connection,\n            source,\n            mint,\n            destination,\n            authorityPublicKey,\n            amount,\n            decimals,\n            fee,\n            signers,\n            confirmOptions?.commitment,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Commitment, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\n\nexport enum TransferHookInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface InitializeTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Initialize;\n    authority: PublicKey;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct<InitializeTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('authority'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n    initializeTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Initialize,\n            authority,\n            transferHookProgramId,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface UpdateTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Update;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct<UpdateTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateTransferHookInstructionData.span);\n    updateTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Update,\n            transferHookProgramId,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nfunction deEscalateAccountMeta(accountMeta: AccountMeta, accountMetas: AccountMeta[]): AccountMeta {\n    const maybeHighestPrivileges = accountMetas\n        .filter(x => x.pubkey.equals(accountMeta.pubkey))\n        .reduce<{ isSigner: boolean; isWritable: boolean } | undefined>((acc, x) => {\n            if (!acc) return { isSigner: x.isSigner, isWritable: x.isWritable };\n            return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };\n        }, undefined);\n    if (maybeHighestPrivileges) {\n        const { isSigner, isWritable } = maybeHighestPrivileges;\n        if (!isSigner && isSigner !== accountMeta.isSigner) {\n            accountMeta.isSigner = false;\n        }\n        if (!isWritable && isWritable !== accountMeta.isWritable) {\n            accountMeta.isWritable = false;\n        }\n    }\n    return accountMeta;\n}\n\n/**\n * Construct an `ExecuteInstruction` for a transfer hook program, without the\n * additional accounts\n *\n * @param programId             The program ID of the transfer hook program\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param validateStatePubkey   The validate state pubkey\n * @param amount                The amount of tokens to transfer\n * @returns Instruction to add to a transaction\n */\nexport function createExecuteInstruction(\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    validateStatePubkey: PublicKey,\n    amount: bigint,\n): TransactionInstruction {\n    const keys = [source, mint, destination, owner, validateStatePubkey].map(pubkey => ({\n        pubkey,\n        isSigner: false,\n        isWritable: false,\n    }));\n\n    const data = Buffer.alloc(16);\n    data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0); // `ExecuteInstruction` discriminator\n    data.writeBigUInt64LE(BigInt(amount), 8);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Adds all the extra accounts needed for a transfer hook to an instruction.\n *\n * Note this will modify the instruction passed in.\n *\n * @param connection            Connection to use\n * @param instruction           The instruction to add accounts to\n * @param programId             Transfer hook program ID\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param commitment            Commitment to use\n */\nexport async function addExtraAccountMetasForExecute(\n    connection: Connection,\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    commitment?: Commitment,\n) {\n    const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);\n    const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);\n    if (validateStateAccount == null) {\n        return instruction;\n    }\n    const validateStateData = getExtraAccountMetas(validateStateAccount);\n\n    // Check to make sure the provided keys are in the instruction\n    if (![source, mint, destination, owner].every(key => instruction.keys.some(meta => meta.pubkey.equals(key)))) {\n        throw new Error('Missing required account in instruction');\n    }\n\n    const executeInstruction = createExecuteInstruction(\n        programId,\n        source,\n        mint,\n        destination,\n        owner,\n        validateStatePubkey,\n        BigInt(amount),\n    );\n\n    for (const extraAccountMeta of validateStateData) {\n        executeInstruction.keys.push(\n            deEscalateAccountMeta(\n                await resolveExtraAccountMeta(\n                    connection,\n                    extraAccountMeta,\n                    executeInstruction.keys,\n                    executeInstruction.data,\n                    executeInstruction.programId,\n                ),\n                executeInstruction.keys,\n            ),\n        );\n    }\n\n    // Add only the extra accounts resolved from the validation state\n    instruction.keys.push(...executeInstruction.keys.slice(5));\n\n    // Add the transfer hook program ID and the validation state account\n    instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });\n    instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n) {\n    const instruction = createTransferCheckedInstruction(\n        source,\n        mint,\n        destination,\n        owner,\n        amount,\n        decimals,\n        multiSigners,\n        programId,\n    );\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(\n            connection,\n            instruction,\n            transferHook.programId,\n            source,\n            mint,\n            destination,\n            owner,\n            amount,\n            commitment,\n        );\n    }\n\n    return instruction;\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n) {\n    const instruction = createTransferCheckedWithFeeInstruction(\n        source,\n        mint,\n        destination,\n        owner,\n        amount,\n        decimals,\n        fee,\n        multiSigners,\n        programId,\n    );\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(\n            connection,\n            instruction,\n            transferHook.programId,\n            source,\n            mint,\n            destination,\n            owner,\n            amount,\n            commitment,\n        );\n    }\n\n    return instruction;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface TransferCheckedInstructionData {\n    instruction: TokenInstruction.TransferChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const transferCheckedInstructionData = struct<TransferCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a TransferChecked instruction\n *\n * @param source       Source account\n * @param mint         Mint account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param decimals     Number of decimals in transfer amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(transferCheckedInstructionData.span);\n    transferCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferChecked instruction */\nexport interface DecodedTransferCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.TransferChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedTransferCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, owner, multiSigners },\n        data,\n    } = decodeTransferCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferChecked) throw new TokenInvalidInstructionTypeError();\n    if (!source || !mint || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferChecked instruction */\nexport interface DecodedTransferCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferCheckedInstructionData.decode(data),\n    };\n}\n", "import { blob, greedy, seq, struct, u32, u8 } from '@solana/buffer-layout';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport type { AccountInfo, AccountMeta, Connection } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { Account } from '../../state/account.js';\nimport { TokenTransferHookAccountNotFound } from '../../errors.js';\nimport { unpackSeeds } from './seeds.js';\nimport { unpackPubkeyData } from './pubkeyData.js';\n\n/** TransferHook as stored by the program */\nexport interface TransferHook {\n    /** The transfer hook update authority */\n    authority: PublicKey;\n    /** The transfer hook program account */\n    programId: PublicKey;\n}\n\n/** Buffer layout for de/serializing a transfer hook extension */\nexport const TransferHookLayout = struct<TransferHook>([publicKey('authority'), publicKey('programId')]);\n\nexport const TRANSFER_HOOK_SIZE = TransferHookLayout.span;\n\nexport function getTransferHook(mint: Mint): TransferHook | null {\n    const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);\n    if (extensionData !== null) {\n        return TransferHookLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\n/** TransferHookAccount as stored by the program */\nexport interface TransferHookAccount {\n    /**\n     * Whether or not this account is currently transferring tokens\n     * True during the transfer hook cpi, otherwise false\n     */\n    transferring: boolean;\n}\n\n/** Buffer layout for de/serializing a transfer hook account extension */\nexport const TransferHookAccountLayout = struct<TransferHookAccount>([bool('transferring')]);\n\nexport const TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;\n\nexport function getTransferHookAccount(account: Account): TransferHookAccount | null {\n    const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);\n    if (extensionData !== null) {\n        return TransferHookAccountLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\nexport function getExtraAccountMetaAddress(mint: PublicKey, programId: PublicKey): PublicKey {\n    const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\n    return PublicKey.findProgramAddressSync(seeds, programId)[0];\n}\n\n/** ExtraAccountMeta as stored by the transfer hook program */\nexport interface ExtraAccountMeta {\n    discriminator: number;\n    addressConfig: Uint8Array;\n    isSigner: boolean;\n    isWritable: boolean;\n}\n\n/** Buffer layout for de/serializing an ExtraAccountMeta */\nexport const ExtraAccountMetaLayout = struct<ExtraAccountMeta>([\n    u8('discriminator'),\n    blob(32, 'addressConfig'),\n    bool('isSigner'),\n    bool('isWritable'),\n]);\n\nexport interface ExtraAccountMetaList {\n    count: number;\n    extraAccounts: ExtraAccountMeta[];\n}\n\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\nexport const ExtraAccountMetaListLayout = struct<ExtraAccountMetaList>([\n    u32('count'),\n    seq<ExtraAccountMeta>(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), 'extraAccounts'),\n]);\n\n/** Buffer layout for de/serializing a list of ExtraAccountMetaAccountData prefixed by a u32 length */\nexport interface ExtraAccountMetaAccountData {\n    instructionDiscriminator: bigint;\n    length: number;\n    extraAccountsList: ExtraAccountMetaList;\n}\n\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\nexport const ExtraAccountMetaAccountDataLayout = struct<ExtraAccountMetaAccountData>([\n    u64('instructionDiscriminator'),\n    u32('length'),\n    ExtraAccountMetaListLayout.replicate('extraAccountsList'),\n]);\n\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\nexport function getExtraAccountMetas(account: AccountInfo<Buffer>): ExtraAccountMeta[] {\n    const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\n    return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\n}\n\n/** Take an ExtraAccountMeta and construct that into an actual AccountMeta */\nexport async function resolveExtraAccountMeta(\n    connection: Connection,\n    extraMeta: ExtraAccountMeta,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    transferHookProgramId: PublicKey,\n): Promise<AccountMeta> {\n    if (extraMeta.discriminator === 0) {\n        return {\n            pubkey: new PublicKey(extraMeta.addressConfig),\n            isSigner: extraMeta.isSigner,\n            isWritable: extraMeta.isWritable,\n        };\n    } else if (extraMeta.discriminator === 2) {\n        const pubkey = await unpackPubkeyData(extraMeta.addressConfig, previousMetas, instructionData, connection);\n        return {\n            pubkey,\n            isSigner: extraMeta.isSigner,\n            isWritable: extraMeta.isWritable,\n        };\n    }\n\n    let programId = PublicKey.default;\n\n    if (extraMeta.discriminator === 1) {\n        programId = transferHookProgramId;\n    } else {\n        const accountIndex = extraMeta.discriminator - (1 << 7);\n        if (previousMetas.length <= accountIndex) {\n            throw new TokenTransferHookAccountNotFound();\n        }\n        programId = previousMetas[accountIndex].pubkey;\n    }\n\n    const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);\n    const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];\n\n    return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };\n}\n", "import type { AccountMeta, Connection } from '@solana/web3.js';\nimport { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidSeed } from '../../errors.js';\n\ninterface Seed {\n    data: Buffer;\n    packedLength: number;\n}\n\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\n\nfunction unpackSeedLiteral(seeds: Uint8Array): Seed {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [length, ...rest] = seeds;\n    if (rest.length < length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: Buffer.from(rest.slice(0, length)),\n        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length,\n    };\n}\n\nfunction unpackSeedInstructionArg(seeds: Uint8Array, instructionData: Buffer): Seed {\n    if (seeds.length < 2) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index, length] = seeds;\n    if (instructionData.length < length + index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: instructionData.subarray(index, index + length),\n        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN,\n    };\n}\n\nfunction unpackSeedAccountKey(seeds: Uint8Array, previousMetas: AccountMeta[]): Seed {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index] = seeds;\n    if (previousMetas.length <= index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: previousMetas[index].pubkey.toBuffer(),\n        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN,\n    };\n}\n\nasync function unpackSeedAccountData(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    connection: Connection,\n): Promise<Seed> {\n    if (seeds.length < 3) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [accountIndex, dataIndex, length] = seeds;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n        packedLength:\n            DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN,\n    };\n}\n\nasync function unpackFirstSeed(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<Seed | null> {\n    const [discriminator, ...rest] = seeds;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 0:\n            return null;\n        case 1:\n            return unpackSeedLiteral(remaining);\n        case 2:\n            return unpackSeedInstructionArg(remaining, instructionData);\n        case 3:\n            return unpackSeedAccountKey(remaining, previousMetas);\n        case 4:\n            return unpackSeedAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidSeed();\n    }\n}\n\nexport async function unpackSeeds(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<Buffer[]> {\n    const unpackedSeeds: Buffer[] = [];\n    let i = 0;\n    while (i < 32) {\n        const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n        if (seed == null) {\n            break;\n        }\n        unpackedSeeds.push(seed.data);\n        i += seed.packedLength;\n    }\n    return unpackedSeeds;\n}\n", "import { PUBLIC_KEY_LENGTH, PublicKey } from '@solana/web3.js';\nimport type { AccountMeta, Connection } from '@solana/web3.js';\nimport {\n    TokenTransferHookAccountDataNotFound,\n    TokenTransferHookInvalidPubkeyData,\n    TokenTransferHookPubkeyDataTooSmall,\n    TokenTransferHookAccountNotFound,\n} from '../../errors.js';\n\nexport async function unpackPubkeyData(\n    keyDataConfig: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<PublicKey> {\n    const [discriminator, ...rest] = keyDataConfig;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 1:\n            return unpackPubkeyDataFromInstructionData(remaining, instructionData);\n        case 2:\n            return unpackPubkeyDataFromAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidPubkeyData();\n    }\n}\n\nfunction unpackPubkeyDataFromInstructionData(remaining: Uint8Array, instructionData: Buffer): PublicKey {\n    if (remaining.length < 1) {\n        throw new TokenTransferHookInvalidPubkeyData();\n    }\n    const dataIndex = remaining[0];\n    if (instructionData.length < dataIndex + PUBLIC_KEY_LENGTH) {\n        throw new TokenTransferHookPubkeyDataTooSmall();\n    }\n    return new PublicKey(instructionData.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));\n}\n\nasync function unpackPubkeyDataFromAccountData(\n    remaining: Uint8Array,\n    previousMetas: AccountMeta[],\n    connection: Connection,\n): Promise<PublicKey> {\n    if (remaining.length < 2) {\n        throw new TokenTransferHookInvalidPubkeyData();\n    }\n    const [accountIndex, dataIndex] = remaining;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + PUBLIC_KEY_LENGTH) {\n        throw new TokenTransferHookPubkeyDataTooSmall();\n    }\n    return new PublicKey(accountInfo.data.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveInstruction } from '../instructions/approve.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param delegate       Account authorized to transfer tokens from the account\n * @param owner          Owner of the account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approve(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ApproveInstructionData {\n    instruction: TokenInstruction.Approve;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const approveInstructionData = struct<ApproveInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct an Approve instruction\n *\n * @param account      Account to set the delegate for\n * @param delegate     Account authorized to transfer tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveInstruction(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(approveInstructionData.span);\n    approveInstructionData.encode(\n        {\n            instruction: TokenInstruction.Approve,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Approve instruction */\nexport interface DecodedApproveInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Approve;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode an Approve instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedApproveInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Approve) throw new TokenInvalidInstructionTypeError();\n    if (!account || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Approve instruction */\nexport interface DecodedApproveInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode an Approve instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveInstructionUnchecked({\n    programId,\n    keys: [account, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveCheckedInstruction } from '../instructions/approveChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account, asserting the token mint and\n * decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Address of the mint\n * @param account        Address of the account\n * @param delegate       Account authorized to perform a transfer tokens from the source account\n * @param owner          Owner of the source account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param decimals       Number of decimals in approve amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approveChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveCheckedInstruction(\n            account,\n            mint,\n            delegate,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ApproveCheckedInstructionData {\n    instruction: TokenInstruction.ApproveChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const approveCheckedInstructionData = struct<ApproveCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct an ApproveChecked instruction\n *\n * @param account      Account to set the delegate for\n * @param mint         Mint account\n * @param delegate     Account authorized to transfer of tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param decimals     Number of decimals in approve amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(approveCheckedInstructionData.span);\n    approveCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.ApproveChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ApproveChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedApproveCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ApproveChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveCheckedInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnInstruction } from '../instructions/burn.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Burn tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burn(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface BurnInstructionData {\n    instruction: TokenInstruction.Burn;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const burnInstructionData = struct<BurnInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Burn instruction\n *\n * @param account      Account to burn tokens from\n * @param mint         Mint for the account\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(burnInstructionData.span);\n    burnInstructionData.encode(\n        {\n            instruction: TokenInstruction.Burn,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Burn instruction */\nexport interface DecodedBurnInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Burn;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedBurnInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Burn) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Burn instruction */\nexport interface DecodedBurnInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnCheckedInstruction } from '../instructions/burnChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Burn tokens from an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param decimals       Number of decimals in amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burnChecked(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface BurnCheckedInstructionData {\n    instruction: TokenInstruction.BurnChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const burnCheckedInstructionData = struct<BurnCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a BurnChecked instruction\n *\n * @param mint         Mint for the account\n * @param account      Account to burn tokens from\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param decimals     Number of decimals in burn amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(burnCheckedInstructionData.span);\n    burnCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.BurnChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid BurnChecked instruction */\nexport interface DecodedBurnCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.BurnChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedBurnCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.BurnChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated BurnChecked instruction */\nexport interface DecodedBurnCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnCheckedInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createCloseAccountInstruction } from '../instructions/closeAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Close a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to close\n * @param destination    Account to receive the remaining balance of the closed account\n * @param authority      Authority which is allowed to close the account\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function closeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface CloseAccountInstructionData {\n    instruction: TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport const closeAccountInstructionData = struct<CloseAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CloseAccount instruction\n *\n * @param account      Account to close\n * @param destination  Account to receive the remaining balance of the closed account\n * @param authority    Account close authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCloseAccountInstruction(\n    account: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(closeAccountInstructionData.span);\n    closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid CloseAccount instruction */\nexport interface DecodedCloseAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.CloseAccount;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeCloseAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedCloseAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== closeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, destination, authority, multiSigners },\n        data,\n    } = decodeCloseAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.CloseAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated CloseAccount instruction */\nexport interface DecodedCloseAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeCloseAccountInstructionUnchecked({\n    programId,\n    keys: [account, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedCloseAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: closeAccountInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, Keypair, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAccountLenForMint } from '../extensions/extensionType.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { getMint } from '../state/mint.js';\nimport { createAssociatedTokenAccount } from './createAssociatedTokenAccount.js';\n\n/**\n * Create and initialize a new token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param mint           Mint for the account\n * @param owner          Owner of the new account\n * @param keypair        Optional keypair, defaulting to the associated token account for the `mint` and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new token account\n */\nexport async function createAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    // If a keypair isn't provided, create the associated token account and return its address\n    if (!keypair) return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const mintState = await getMint(connection, mint, confirmOptions?.commitment, programId);\n    const space = getAccountLenForMint(mintState);\n    const lamports = await connection.getMinimumBalanceForRentExemption(space);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space,\n            lamports,\n            programId,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeAccountInstructionData {\n    instruction: TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport const initializeAccountInstructionData = struct<InitializeAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct an InitializeAccount instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(initializeAccountInstructionData.span);\n    initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount instruction */\nexport interface DecodedInitializeAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount;\n    };\n}\n\n/**\n * Decode an InitializeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, rent },\n        data,\n    } = decodeInitializeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount instruction */\nexport interface DecodedInitializeAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode an InitializeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data: initializeAccountInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Create and initialize a new associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n *\n * @return Address of the new associated token account\n */\nexport async function createAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n    allowOwnerOffCurve = false,\n): Promise<PublicKey> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId,\n        ),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n", "import type { PublicKey } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Construct a CreateAssociatedTokenAccount instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    return buildAssociatedTokenAccountInstruction(\n        payer,\n        associatedToken,\n        owner,\n        mint,\n        Buffer.alloc(0),\n        programId,\n        associatedTokenProgramId,\n    );\n}\n\n/**\n * Construct a CreateAssociatedTokenAccountIdempotent instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountIdempotentInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    return buildAssociatedTokenAccountInstruction(\n        payer,\n        associatedToken,\n        owner,\n        mint,\n        Buffer.from([1]),\n        programId,\n        associatedTokenProgramId,\n    );\n}\n\n/**\n * Derive the associated token account and construct a CreateAssociatedTokenAccountIdempotent instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountIdempotentInstructionWithDerivation(\n    payer: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    allowOwnerOffCurve = true,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n) {\n    const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve);\n\n    return createAssociatedTokenAccountIdempotentInstruction(\n        payer,\n        associatedToken,\n        owner,\n        mint,\n        programId,\n        associatedTokenProgramId,\n    );\n}\n\nfunction buildAssociatedTokenAccountInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    instructionData: Buffer,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: associatedToken, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n        { pubkey: programId, isSigner: false, isWritable: false },\n    ];\n\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: instructionData,\n    });\n}\n\n/**\n * Construct a RecoverNested instruction\n *\n * @param nestedAssociatedToken             Nested associated token account (must be owned by `ownerAssociatedToken`)\n * @param nestedMint                        Token mint for the nested associated token account\n * @param destinationAssociatedToken        Wallet's associated token account\n * @param ownerAssociatedToken              Owner associated token account address (must be owned by `owner`)\n * @param ownerMint                         Token mint for the owner associated token account\n * @param owner                             Wallet address for the owner associated token account\n * @param programId                         SPL Token program account\n * @param associatedTokenProgramId          SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRecoverNestedInstruction(\n    nestedAssociatedToken: PublicKey,\n    nestedMint: PublicKey,\n    destinationAssociatedToken: PublicKey,\n    ownerAssociatedToken: PublicKey,\n    ownerMint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: nestedMint, isSigner: false, isWritable: false },\n        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: ownerMint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: true, isWritable: true },\n        { pubkey: programId, isSigner: false, isWritable: false },\n    ];\n\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: Buffer.from([2]),\n    });\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountIdempotentInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Create and initialize a new associated token account\n * The instruction will succeed even if the associated token account already exists\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n *\n * @return Address of the new or existing associated token account\n */\nexport async function createAssociatedTokenAccountIdempotent(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n    allowOwnerOffCurve = false,\n): Promise<PublicKey> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountIdempotentInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId,\n        ),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMint2Instruction } from '../instructions/initializeMint2.js';\nimport { getMinimumBalanceForRentExemptMint, MINT_SIZE } from '../state/mint.js';\n\n/**\n * Create and initialize a new mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction and initialization fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Address of the new mint\n */\nexport async function createMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMint(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MINT_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMint2Instruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** TODO: docs */\nexport interface InitializeMint2InstructionData {\n    instruction: TokenInstruction.InitializeMint2;\n    decimals: number;\n    mintAuthority: PublicKey;\n    freezeAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const initializeMint2InstructionData = struct<InitializeMint2InstructionData>([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    new COptionPublicKeyLayout('freezeAuthority'),\n]);\n\n/**\n * Construct an InitializeMint2 instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMint2Instruction(\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(67); // worst-case size\n    initializeMint2InstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMint2,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMint2InstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeMint2 instruction */\nexport interface DecodedInitializeMint2Instruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMint2;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMint2Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeMint2Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMint2InstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeMint2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint2) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMint2 instruction */\nexport interface DecodedInitializeMint2InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMint2InstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeMint2InstructionUnchecked {\n    const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMint2InstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMultisigInstruction } from '../instructions/initializeMultisig.js';\nimport { getMinimumBalanceForRentExemptMultisig, MULTISIG_SIZE } from '../state/multisig.js';\n\n/**\n * Create and initialize a new multisig\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param signers        Full set of signers\n * @param m              Number of required signatures\n * @param keypair        Optional keypair, defaulting to a new random one\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new multisig\n */\nexport async function createMultisig(\n    connection: Connection,\n    payer: Signer,\n    signers: PublicKey[],\n    m: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMultisig(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MULTISIG_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeMultisigInstructionData {\n    instruction: TokenInstruction.InitializeMultisig;\n    m: number;\n}\n\n/** TODO: docs */\nexport const initializeMultisigInstructionData = struct<InitializeMultisigInstructionData>([\n    u8('instruction'),\n    u8('m'),\n]);\n\n/**\n * Construct an InitializeMultisig instruction\n *\n * @param account   Multisig account\n * @param signers   Full set of signers\n * @param m         Number of required signatures\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMultisigInstruction(\n    account: PublicKey,\n    signers: (Signer | PublicKey)[],\n    m: number,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    for (const signer of signers) {\n        keys.push({\n            pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n\n    const data = Buffer.alloc(initializeMultisigInstructionData.span);\n    initializeMultisigInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMultisig,\n            m,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        rent: AccountMeta;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMultisig;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMultisigInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeMultisigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMultisigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, rent, signers },\n        data,\n    } = decodeInitializeMultisigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMultisig) throw new TokenInvalidInstructionTypeError();\n    if (!account || !rent || !signers.length) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMultisigInstructionUnchecked({\n    programId,\n    keys: [account, rent, ...signers],\n    data,\n}: TransactionInstruction): DecodedInitializeMultisigInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data: initializeMultisigInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { createCreateNativeMintInstruction } from '../instructions/createNativeMint.js';\n\n/**\n * Create native mint\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param nativeMint               Native mint id associated with program\n */\nexport async function createNativeMint(\n    connection: Connection,\n    payer: Signer,\n    confirmOptions?: ConfirmOptions,\n    nativeMint = NATIVE_MINT_2022,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<void> {\n    const transaction = new Transaction().add(\n        createCreateNativeMintInstruction(payer.publicKey, nativeMint, programId),\n    );\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface CreateNativeMintInstructionData {\n    instruction: TokenInstruction.CreateNativeMint;\n}\n\n/** TODO: docs */\nexport const createNativeMintInstructionData = struct<CreateNativeMintInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CreateNativeMint instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCreateNativeMintInstruction(\n    payer: PublicKey,\n    nativeMintId = NATIVE_MINT_2022,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: nativeMintId, isSigner: false, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(createNativeMintInstructionData.span);\n    createNativeMintInstructionData.encode({ instruction: TokenInstruction.CreateNativeMint }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import type { ConfirmOptions, Connection, Keypair, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\nimport { ACCOUNT_SIZE, getMinimumBalanceForRentExemptAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\nimport { createAccount } from './createAccount.js';\n\n/**\n * Create, initialize, and fund a new wrapped native SOL account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param owner          Owner of the new token account\n * @param amount         Number of lamports to wrap\n * @param keypair        Optional keypair, defaulting to the associated token account for the native mint and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new wrapped native SOL account\n */\nexport async function createWrappedNativeAccount(\n    connection: Connection,\n    payer: Signer,\n    owner: PublicKey,\n    amount: number,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    nativeMint = NATIVE_MINT,\n): Promise<PublicKey> {\n    // If the amount provided is explicitly 0 or NaN, just create the account without funding it\n    if (!amount) return await createAccount(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);\n\n    // If a keypair isn't provided, create the account at the owner's ATA for the native mint and return its address\n    if (!keypair) {\n        const associatedToken = getAssociatedTokenAddressSync(\n            nativeMint,\n            owner,\n            false,\n            programId,\n            ASSOCIATED_TOKEN_PROGRAM_ID,\n        );\n\n        const transaction = new Transaction().add(\n            createAssociatedTokenAccountInstruction(\n                payer.publicKey,\n                associatedToken,\n                owner,\n                nativeMint,\n                programId,\n                ASSOCIATED_TOKEN_PROGRAM_ID,\n            ),\n            SystemProgram.transfer({\n                fromPubkey: payer.publicKey,\n                toPubkey: associatedToken,\n                lamports: amount,\n            }),\n            createSyncNativeInstruction(associatedToken, programId),\n        );\n\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n        return associatedToken;\n    }\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const lamports = await getMinimumBalanceForRentExemptAccount(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: ACCOUNT_SIZE,\n            lamports,\n            programId,\n        }),\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: keypair.publicKey,\n            lamports: amount,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, nativeMint, owner, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface SyncNativeInstructionData {\n    instruction: TokenInstruction.SyncNative;\n}\n\n/** TODO: docs */\nexport const syncNativeInstructionData = struct<SyncNativeInstructionData>([u8('instruction')]);\n\n/**\n * Construct a SyncNative instruction\n *\n * @param account   Native account to sync lamports from\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSyncNativeInstruction(account: PublicKey, programId = TOKEN_PROGRAM_ID): TransactionInstruction {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(syncNativeInstructionData.span);\n    syncNativeInstructionData.encode({ instruction: TokenInstruction.SyncNative }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SyncNative instruction */\nexport interface DecodedSyncNativeInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.SyncNative;\n    };\n}\n\n/**\n * Decode a SyncNative instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSyncNativeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedSyncNativeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== syncNativeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account },\n        data,\n    } = decodeSyncNativeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SyncNative) throw new TokenInvalidInstructionTypeError();\n    if (!account) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SyncNative instruction */\nexport interface DecodedSyncNativeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a SyncNative instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSyncNativeInstructionUnchecked({\n    programId,\n    keys: [account],\n    data,\n}: TransactionInstruction): DecodedSyncNativeInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data: syncNativeInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createFreezeAccountInstruction } from '../instructions/freezeAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Freeze a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to freeze\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function freezeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface FreezeAccountInstructionData {\n    instruction: TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport const freezeAccountInstructionData = struct<FreezeAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a FreezeAccount instruction\n *\n * @param account      Account to freeze\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createFreezeAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(freezeAccountInstructionData.span);\n    freezeAccountInstructionData.encode({ instruction: TokenInstruction.FreezeAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid FreezeAccount instruction */\nexport interface DecodedFreezeAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.FreezeAccount;\n    };\n}\n\n/**\n * Decode a FreezeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeFreezeAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedFreezeAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== freezeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, authority, multiSigners },\n        data,\n    } = decodeFreezeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.FreezeAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated FreezeAccount instruction */\nexport interface DecodedFreezeAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a FreezeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeFreezeAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedFreezeAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: freezeAccountInstructionData.decode(data),\n    };\n}\n", "import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<Account> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId,\n                    ),\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToInstruction } from '../instructions/mintTo.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Mint tokens to an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintTo(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface MintToInstructionData {\n    instruction: TokenInstruction.MintTo;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const mintToInstructionData = struct<MintToInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a MintTo instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(mintToInstructionData.span);\n    mintToInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintTo,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintTo instruction */\nexport interface DecodedMintToInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintTo;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a MintTo instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedMintToInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintTo) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintTo instruction */\nexport interface DecodedMintToInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a MintTo instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToCheckedInstruction } from '../instructions/mintToChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Mint tokens to an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param decimals       Number of decimals in amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintToChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToCheckedInstruction(\n            mint,\n            destination,\n            authorityPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface MintToCheckedInstructionData {\n    instruction: TokenInstruction.MintToChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const mintToCheckedInstructionData = struct<MintToCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a MintToChecked instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param decimals     Number of decimals in amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToCheckedInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(mintToCheckedInstructionData.span);\n    mintToCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintToChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintToChecked instruction */\nexport interface DecodedMintToCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintToChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedMintToCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintToChecked) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintToChecked instruction */\nexport interface DecodedMintToCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToCheckedInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToCheckedInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRecoverNestedInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Recover funds funds in an associated token account which is owned by an associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param owner                    Owner of original ATA\n * @param mint                     Mint for the original ATA\n * @param nestedMint               Mint for the nested ATA\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function recoverNested(\n    connection: Connection,\n    payer: Signer,\n    owner: Signer,\n    mint: PublicKey,\n    nestedMint: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const ownerAssociatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner.publicKey,\n        false,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const destinationAssociatedToken = getAssociatedTokenAddressSync(\n        nestedMint,\n        owner.publicKey,\n        false,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const nestedAssociatedToken = getAssociatedTokenAddressSync(\n        nestedMint,\n        ownerAssociatedToken,\n        true,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const transaction = new Transaction().add(\n        createRecoverNestedInstruction(\n            nestedAssociatedToken,\n            nestedMint,\n            destinationAssociatedToken,\n            ownerAssociatedToken,\n            mint,\n            owner.publicKey,\n            programId,\n            associatedTokenProgramId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, owner], confirmOptions);\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRevokeInstruction } from '../instructions/revoke.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Revoke approval for the transfer of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function revoke(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRevokeInstruction(account, ownerPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface RevokeInstructionData {\n    instruction: TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport const revokeInstructionData = struct<RevokeInstructionData>([u8('instruction')]);\n\n/**\n * Construct a Revoke instruction\n *\n * @param account      Address of the token account\n * @param owner        Owner of the account\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRevokeInstruction(\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);\n\n    const data = Buffer.alloc(revokeInstructionData.span);\n    revokeInstructionData.encode({ instruction: TokenInstruction.Revoke }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Revoke instruction */\nexport interface DecodedRevokeInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Revoke;\n    };\n}\n\n/**\n * Decode a Revoke instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeRevokeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedRevokeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== revokeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, owner, multiSigners },\n        data,\n    } = decodeRevokeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Revoke) throw new TokenInvalidInstructionTypeError();\n    if (!account || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Revoke instruction */\nexport interface DecodedRevokeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a Revoke instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeRevokeInstructionUnchecked({\n    programId,\n    keys: [account, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedRevokeInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data: revokeInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport type { AuthorityType } from '../instructions/setAuthority.js';\nimport { createSetAuthorityInstruction } from '../instructions/setAuthority.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Assign a new authority to the account\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param account          Address of the account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setAuthority(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    currentAuthority: Signer | PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createSetAuthorityInstruction(\n            account,\n            currentAuthorityPublicKey,\n            authorityType,\n            newAuthority,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** Authority types defined by the program */\nexport enum AuthorityType {\n    MintTokens = 0,\n    FreezeAccount = 1,\n    AccountOwner = 2,\n    CloseAccount = 3,\n    TransferFeeConfig = 4,\n    WithheldWithdraw = 5,\n    CloseMint = 6,\n    InterestRate = 7,\n    PermanentDelegate = 8,\n    ConfidentialTransferMint = 9,\n    TransferHookProgramId = 10,\n    ConfidentialTransferFeeConfig = 11,\n    MetadataPointer = 12,\n    GroupPointer = 13,\n    GroupMemberPointer = 14,\n    ScaledUiAmountConfig = 15,\n    PausableConfig = 16,\n}\n\n/** TODO: docs */\nexport interface SetAuthorityInstructionData {\n    instruction: TokenInstruction.SetAuthority;\n    authorityType: AuthorityType;\n    newAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const setAuthorityInstructionData = struct<SetAuthorityInstructionData>([\n    u8('instruction'),\n    u8('authorityType'),\n    new COptionPublicKeyLayout('newAuthority'),\n]);\n\n/**\n * Construct a SetAuthority instruction\n *\n * @param account          Address of the token account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param programId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetAuthorityInstruction(\n    account: PublicKey,\n    currentAuthority: PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);\n\n    const data = Buffer.alloc(35); // worst-case\n    setAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.SetAuthority,\n            authorityType,\n            newAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, setAuthorityInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid SetAuthority instruction */\nexport interface DecodedSetAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        currentAuthority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.SetAuthority;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedSetAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setAuthorityInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, currentAuthority, multiSigners },\n        data,\n    } = decodeSetAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SetAuthority) throw new TokenInvalidInstructionTypeError();\n    if (!account || !currentAuthority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SetAuthority instruction */\nexport interface DecodedSetAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        currentAuthority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetAuthorityInstructionUnchecked({\n    programId,\n    keys: [account, currentAuthority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedSetAuthorityInstructionUnchecked {\n    const { instruction, authorityType, newAuthority } = setAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data: {\n            instruction,\n            authorityType,\n            newAuthority,\n        },\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\n\n/**\n * Sync the balance of a native SPL token account to the underlying system account's lamports\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Native account to sync\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function syncNative(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createThawAccountInstruction } from '../instructions/thawAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Thaw (unfreeze) a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to thaw\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function thawAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ThawAccountInstructionData {\n    instruction: TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport const thawAccountInstructionData = struct<ThawAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a ThawAccount instruction\n *\n * @param account      Account to thaw\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createThawAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(thawAccountInstructionData.span);\n    thawAccountInstructionData.encode({ instruction: TokenInstruction.ThawAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ThawAccount instruction */\nexport interface DecodedThawAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ThawAccount;\n    };\n}\n\n/**\n * Decode a ThawAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeThawAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedThawAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== thawAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, authority, multiSigners },\n        data,\n    } = decodeThawAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ThawAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ThawAccount instruction */\nexport interface DecodedThawAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a ThawAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeThawAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedThawAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: thawAccountInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferInstruction } from '../instructions/transfer.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Transfer tokens from one account to another\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface TransferInstructionData {\n    instruction: TokenInstruction.Transfer;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const transferInstructionData = struct<TransferInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Transfer instruction\n *\n * @param source       Source account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferInstruction(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(transferInstructionData.span);\n    transferInstructionData.encode(\n        {\n            instruction: TokenInstruction.Transfer,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Transfer instruction */\nexport interface DecodedTransferInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Transfer;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Transfer instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedTransferInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, destination, owner, multiSigners },\n        data,\n    } = decodeTransferInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Transfer) throw new TokenInvalidInstructionTypeError();\n    if (!source || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Transfer instruction */\nexport interface DecodedTransferInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Transfer instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferInstructionUnchecked({\n    programId,\n    keys: [source, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferInstructionData.decode(data),\n    };\n}\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferCheckedInstruction } from '../instructions/transferChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Transfer tokens from one account to another, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferChecked(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import { u64 } from '@solana/buffer-layout-utils';\nimport type { Connection, PublicKey, Signer, TransactionError } from '@solana/web3.js';\nimport { Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createUiAmountToAmountInstruction } from '../instructions/uiAmountToAmount.js';\n\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Ui Amount of tokens to be converted to Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated\n */\nexport async function uiAmountToAmount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    amount: string,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<bigint | TransactionError | null> {\n    const transaction = new Transaction().add(createUiAmountToAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData) {\n        const data = Buffer.from(returnData.data[0], returnData.data[1]);\n        return u64().decode(data);\n    }\n    return err;\n}\n", "import { blob, struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface UiAmountToAmountInstructionData {\n    instruction: TokenInstruction.UiAmountToAmount;\n    amount: Uint8Array;\n}\n\n/** TODO: docs */\n\n/**\n * Construct a UiAmountToAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       UiAmount of tokens to be converted to Amount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUiAmountToAmountInstruction(\n    mint: PublicKey,\n    amount: string,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n    const buf = Buffer.from(amount, 'utf8');\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(buf.length, 'amount'),\n    ]);\n\n    const data = Buffer.alloc(uiAmountToAmountInstructionData.span);\n    uiAmountToAmountInstructionData.encode(\n        {\n            instruction: TokenInstruction.UiAmountToAmount,\n            amount: buf,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid UiAmountToAmount instruction */\nexport interface DecodedUiAmountToAmountInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.UiAmountToAmount;\n        amount: Uint8Array;\n    };\n}\n\n/**\n * Decode a UiAmountToAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeUiAmountToAmountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedUiAmountToAmountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(instruction.data.length - 1, 'amount'),\n    ]);\n    if (instruction.data.length !== uiAmountToAmountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeUiAmountToAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.UiAmountToAmount) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated UiAmountToAmount instruction */\nexport interface DecodedUiAmountToAmountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        amount: Uint8Array;\n    };\n}\n\n/**\n * Decode a UiAmountToAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeUiAmountToAmountInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedUiAmountToAmountInstructionUnchecked {\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(data.length - 1, 'amount'),\n    ]);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: uiAmountToAmountInstructionData.decode(data),\n    };\n}\n", "export * from './accountType.js';\nexport * from './cpiGuard/index.js';\nexport * from './defaultAccountState/index.js';\nexport * from './extensionType.js';\nexport * from './groupMemberPointer/index.js';\nexport * from './groupPointer/index.js';\nexport * from './immutableOwner.js';\nexport * from './interestBearingMint/index.js';\nexport * from './memoTransfer/index.js';\nexport * from './metadataPointer/index.js';\nexport * from './scaledUiAmount/index.js';\nexport * from './tokenGroup/index.js';\nexport * from './tokenMetadata/index.js';\nexport * from './mintCloseAuthority.js';\nexport * from './nonTransferable.js';\nexport * from './transferFee/index.js';\nexport * from './permanentDelegate.js';\nexport * from './transferHook/index.js';\nexport * from './pausable/index.js';\n", "export * from './instructions.js';\nexport * from './state.js';\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum GroupMemberPointerInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\nexport const initializeGroupMemberPointerData = struct<{\n    instruction: TokenInstruction.GroupMemberPointerExtension;\n    groupMemberPointerInstruction: number;\n    authority: PublicKey;\n    memberAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupMemberPointerInstruction'),\n    publicKey('authority'),\n    publicKey('memberAddress'),\n]);\n\n/**\n * Construct an Initialize GroupMemberPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the member address\n * @param memberAddress   Optional Account address that holds the member\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeGroupMemberPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    memberAddress: PublicKey | null,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeGroupMemberPointerData.span);\n    initializeGroupMemberPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupMemberPointerExtension,\n            groupMemberPointerInstruction: GroupMemberPointerInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            memberAddress: memberAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport const updateGroupMemberPointerData = struct<{\n    instruction: TokenInstruction.GroupMemberPointerExtension;\n    groupMemberPointerInstruction: number;\n    memberAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupMemberPointerInstruction'),\n    publicKey('memberAddress'),\n]);\n\nexport function createUpdateGroupMemberPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    memberAddress: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateGroupMemberPointerData.span);\n    updateGroupMemberPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupMemberPointerExtension,\n            groupMemberPointerInstruction: GroupMemberPointerInstruction.Update,\n            memberAddress: memberAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n", "export * from './instructions.js';\nexport * from './state.js';\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum GroupPointerInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\nexport const initializeGroupPointerData = struct<{\n    instruction: TokenInstruction.GroupPointerExtension;\n    groupPointerInstruction: number;\n    authority: PublicKey;\n    groupAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupPointerInstruction'),\n    publicKey('authority'),\n    publicKey('groupAddress'),\n]);\n\n/**\n * Construct an Initialize GroupPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the group address\n * @param groupAddress    Optional Account address that holds the group\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeGroupPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    groupAddress: PublicKey | null,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeGroupPointerData.span);\n    initializeGroupPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupPointerExtension,\n            groupPointerInstruction: GroupPointerInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            groupAddress: groupAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport const updateGroupPointerData = struct<{\n    instruction: TokenInstruction.GroupPointerExtension;\n    groupPointerInstruction: number;\n    groupAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupPointerInstruction'),\n    publicKey('groupAddress'),\n]);\n\nexport function createUpdateGroupPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    groupAddress: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateGroupPointerData.span);\n    updateGroupPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupPointerExtension,\n            groupPointerInstruction: GroupPointerInstruction.Update,\n            groupAddress: groupAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n", "export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createInitializeMintInstruction } from '../../instructions/initializeMint.js';\nimport { ExtensionType, getMintLen } from '../extensionType.js';\nimport {\n    createInitializeInterestBearingMintInstruction,\n    createUpdateRateInterestBearingMintInstruction,\n} from './instructions.js';\n\n/**\n * Initialize an interest bearing account on a mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function createInterestBearingMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<PublicKey> {\n    const mintLen = getMintLen([ExtensionType.InterestBearingConfig]);\n    const lamports = await connection.getMinimumBalanceForRentExemption(mintLen);\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: mintLen,\n            lamports,\n            programId,\n        }),\n        createInitializeInterestBearingMintInstruction(keypair.publicKey, rateAuthority, rate, programId),\n        createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId),\n    );\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n\n/**\n * Update the interest rate of an interest bearing account\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateRateInterestBearingMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    rateAuthority: Signer,\n    rate: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<string> {\n    const [rateAuthorityPublicKey, signers] = getSigners(rateAuthority, multiSigners);\n    const transaction = new Transaction().add(\n        createUpdateRateInterestBearingMintInstruction(mint, rateAuthorityPublicKey, rate, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** TODO: docs */\nexport interface InitializeMintInstructionData {\n    instruction: TokenInstruction.InitializeMint;\n    decimals: number;\n    mintAuthority: PublicKey;\n    freezeAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const initializeMintInstructionData = struct<InitializeMintInstructionData>([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    new COptionPublicKeyLayout('freezeAuthority'),\n]);\n\n/**\n * Construct an InitializeMint instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintInstruction(\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(67); // worst-case size\n    initializeMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMint,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMintInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeMint instruction */\nexport interface DecodedInitializeMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMint;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, rent },\n        data,\n    } = decodeInitializeMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMint instruction */\nexport interface DecodedInitializeMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintInstructionUnchecked({\n    programId,\n    keys: [mint, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeMintInstructionUnchecked {\n    const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n    };\n}\n", "import { s16, struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum InterestBearingMintInstruction {\n    Initialize = 0,\n    UpdateRate = 1,\n}\n\nexport interface InterestBearingMintInitializeInstructionData {\n    instruction: TokenInstruction.InterestBearingMintExtension;\n    interestBearingMintInstruction: InterestBearingMintInstruction.Initialize;\n    rateAuthority: PublicKey;\n    rate: number;\n}\n\nexport interface InterestBearingMintUpdateRateInstructionData {\n    instruction: TokenInstruction.InterestBearingMintExtension;\n    interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate;\n    rate: number;\n}\n\nexport const interestBearingMintInitializeInstructionData = struct<InterestBearingMintInitializeInstructionData>([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    // TODO: Make this an optional public key\n    publicKey('rateAuthority'),\n    s16('rate'),\n]);\n\nexport const interestBearingMintUpdateRateInstructionData = struct<InterestBearingMintUpdateRateInstructionData>([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    s16('rate'),\n]);\n\n/**\n * Construct an InitializeInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The initial interest rate\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeInterestBearingMintInstruction(\n    mint: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    programId = TOKEN_2022_PROGRAM_ID,\n) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(interestBearingMintInitializeInstructionData.span);\n    interestBearingMintInitializeInstructionData.encode(\n        {\n            instruction: TokenInstruction.InterestBearingMintExtension,\n            interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,\n            rateAuthority,\n            rate,\n        },\n        data,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Construct an UpdateRateInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The updated interest rate\n * @param multiSigners   Signing accounts if `rateAuthority` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateRateInterestBearingMintInstruction(\n    mint: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n) {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false },\n        ],\n        rateAuthority,\n        multiSigners,\n    );\n    const data = Buffer.alloc(interestBearingMintUpdateRateInstructionData.span);\n    interestBearingMintUpdateRateInstructionData.encode(\n        {\n            instruction: TokenInstruction.InterestBearingMintExtension,\n            interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,\n            rate,\n        },\n        data,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "export * from './instructions.js';\nexport * from './state.js';\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum MetadataPointerInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\nexport const initializeMetadataPointerData = struct<{\n    instruction: TokenInstruction.MetadataPointerExtension;\n    metadataPointerInstruction: number;\n    authority: PublicKey;\n    metadataAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('metadataPointerInstruction'),\n    publicKey('authority'),\n    publicKey('metadataAddress'),\n]);\n\n/**\n * Construct an Initialize MetadataPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the metadata address\n * @param metadataAddress Optional Account address that holds the metadata\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMetadataPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    metadataAddress: PublicKey | null,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeMetadataPointerData.span);\n    initializeMetadataPointerData.encode(\n        {\n            instruction: TokenInstruction.MetadataPointerExtension,\n            metadataPointerInstruction: MetadataPointerInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            metadataAddress: metadataAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport const updateMetadataPointerData = struct<{\n    instruction: TokenInstruction.MetadataPointerExtension;\n    metadataPointerInstruction: number;\n    metadataAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('metadataPointerInstruction'),\n    publicKey('metadataAddress'),\n]);\n\nexport function createUpdateMetadataPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    metadataAddress: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateMetadataPointerData.span);\n    updateMetadataPointerData.encode(\n        {\n            instruction: TokenInstruction.MetadataPointerExtension,\n            metadataPointerInstruction: MetadataPointerInstruction.Update,\n            metadataAddress: metadataAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n", "export * from './actions.js';\nexport * from './state.js';\n", "import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport type { Field, TokenMetadata } from '@solana/spl-token-metadata';\nimport {\n    createInitializeInstruction,\n    createRemoveKeyInstruction,\n    createUpdateAuthorityInstruction,\n    createUpdateFieldInstruction,\n    pack,\n    unpack,\n} from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\n\nasync function getAdditionalRentForNewMetadata(\n    connection: Connection,\n    address: PublicKey,\n    tokenMetadata: TokenMetadata,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const extensionLen = pack(tokenMetadata).length;\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId,\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\nasync function getAdditionalRentForUpdatedMetadata(\n    connection: Connection,\n    address: PublicKey,\n    field: string | Field,\n    value: string,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n    if (extensionData === null) {\n        throw new Error('TokenMetadata extension not initialized');\n    }\n\n    const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n    const extensionLen = pack(updatedTokenMetadata).length;\n\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId,\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForNewMetadata(\n        connection,\n        mint,\n        {\n            updateAuthority,\n            mint,\n            name,\n            symbol,\n            uri,\n            additionalMetadata: [],\n        },\n        programId,\n    );\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    key: string,\n    idempotent: boolean,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRemoveKeyInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            key,\n            idempotent,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateAuthorityInstruction({\n            programId,\n            metadata: mint,\n            oldAuthority: updateAuthorityPublicKey,\n            newAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n", "import type { Commitment, Connection } from '@solana/web3.js';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { TokenMetadata } from '@solana/spl-token-metadata';\nimport { Field, unpack } from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { getMint } from '../../state/mint.js';\n\nconst getNormalizedTokenMetadataField = (field: Field | string): string => {\n    if (field === Field.Name || field === 'Name' || field === 'name') {\n        return 'name';\n    }\n\n    if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n        return 'symbol';\n    }\n\n    if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n        return 'uri';\n    }\n\n    return field;\n};\n\nexport function updateTokenMetadata(current: TokenMetadata, key: Field | string, value: string): TokenMetadata {\n    const field = getNormalizedTokenMetadataField(key);\n\n    if (field === 'mint' || field === 'updateAuthority') {\n        throw new Error(`Cannot update ${field} via this instruction`);\n    }\n\n    // Handle updates to default keys\n    if (['name', 'symbol', 'uri'].includes(field)) {\n        return {\n            ...current,\n            [field]: value,\n        };\n    }\n\n    // Avoid mutating input, make a shallow copy\n    const additionalMetadata = [...current.additionalMetadata];\n\n    const i = current.additionalMetadata.findIndex(x => x[0] === field);\n\n    if (i === -1) {\n        // Key was not found, add it\n        additionalMetadata.push([field, value]);\n    } else {\n        // Key was found, change value\n        additionalMetadata[i] = [field, value];\n    }\n\n    return {\n        ...current,\n        additionalMetadata,\n    };\n}\n\n/**\n * Retrieve Token Metadata Information\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token Metadata information\n */\nexport async function getTokenMetadata(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TokenMetadata | null> {\n    const mintInfo = await getMint(connection, address, commitment, programId);\n    const data = getExtensionData(ExtensionType.TokenMetadata, mintInfo.tlvData);\n\n    if (data === null) {\n        return null;\n    }\n\n    return unpack(data);\n}\n", "export * from './account.js';\nexport * from './mint.js';\nexport * from './multisig.js';\n", "export {\n    createInitializeInstruction,\n    createUpdateFieldInstruction,\n    createRemoveKeyInstruction,\n    createUpdateAuthorityInstruction,\n    createEmitInstruction,\n} from '@solana/spl-token-metadata';\nexport {\n    createInitializeGroupInstruction,\n    createUpdateGroupMaxSizeInstruction,\n    createUpdateGroupAuthorityInstruction,\n    createInitializeMemberInstruction,\n} from '@solana/spl-token-group';\n\nexport * from './associatedTokenAccount.js';\nexport * from './decode.js';\nexport * from './types.js';\n\nexport * from './initializeMint.js'; //                 0\nexport * from './initializeAccount.js'; //              1\nexport * from './initializeMultisig.js'; //             2\nexport * from './transfer.js'; //                       3\nexport * from './approve.js'; //                        4\nexport * from './revoke.js'; //                         5\nexport * from './setAuthority.js'; //                   6\nexport * from './mintTo.js'; //                         7\nexport * from './burn.js'; //                           8\nexport * from './closeAccount.js'; //                   9\nexport * from './freezeAccount.js'; //                 10\nexport * from './thawAccount.js'; //                   11\nexport * from './transferChecked.js'; //               12\nexport * from './approveChecked.js'; //                13\nexport * from './mintToChecked.js'; //                 14\nexport * from './burnChecked.js'; //                   15\nexport * from './initializeAccount2.js'; //            16\nexport * from './syncNative.js'; //                    17\nexport * from './initializeAccount3.js'; //            18\nexport * from './initializeMultisig2.js'; //           19\nexport * from './initializeMint2.js'; //               20\nexport * from './initializeImmutableOwner.js'; //      22\nexport * from './amountToUiAmount.js'; //              23\nexport * from './uiAmountToAmount.js'; //              24\nexport * from './initializeMintCloseAuthority.js'; //  25\nexport * from './reallocate.js'; //                    29\nexport * from './createNativeMint.js'; //              31\nexport * from './initializeNonTransferableMint.js'; // 32\nexport * from './initializePermanentDelegate.js'; //   35\n", "import { u8 } from '@solana/buffer-layout';\nimport type { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionTypeError } from '../errors.js';\nimport type { DecodedAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport { decodeAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport type { DecodedApproveInstruction } from './approve.js';\nimport { decodeApproveInstruction } from './approve.js';\nimport type { DecodedApproveCheckedInstruction } from './approveChecked.js';\nimport { decodeApproveCheckedInstruction } from './approveChecked.js';\nimport type { DecodedBurnInstruction } from './burn.js';\nimport { decodeBurnInstruction } from './burn.js';\nimport type { DecodedBurnCheckedInstruction } from './burnChecked.js';\nimport { decodeBurnCheckedInstruction } from './burnChecked.js';\nimport type { DecodedCloseAccountInstruction } from './closeAccount.js';\nimport { decodeCloseAccountInstruction } from './closeAccount.js';\nimport type { DecodedFreezeAccountInstruction } from './freezeAccount.js';\nimport { decodeFreezeAccountInstruction } from './freezeAccount.js';\nimport type { DecodedInitializeAccountInstruction } from './initializeAccount.js';\nimport { decodeInitializeAccountInstruction } from './initializeAccount.js';\nimport type { DecodedInitializeAccount2Instruction } from './initializeAccount2.js';\nimport { decodeInitializeAccount2Instruction } from './initializeAccount2.js';\nimport type { DecodedInitializeAccount3Instruction } from './initializeAccount3.js';\nimport { decodeInitializeAccount3Instruction } from './initializeAccount3.js';\nimport type { DecodedInitializeMintInstruction } from './initializeMint.js';\nimport { decodeInitializeMintInstruction } from './initializeMint.js';\nimport type { DecodedInitializeMint2Instruction } from './initializeMint2.js';\nimport { decodeInitializeMint2Instruction } from './initializeMint2.js';\nimport type { DecodedInitializeMultisigInstruction } from './initializeMultisig.js';\nimport { decodeInitializeMultisigInstruction } from './initializeMultisig.js';\nimport type { DecodedMintToInstruction } from './mintTo.js';\nimport { decodeMintToInstruction } from './mintTo.js';\nimport type { DecodedMintToCheckedInstruction } from './mintToChecked.js';\nimport { decodeMintToCheckedInstruction } from './mintToChecked.js';\nimport type { DecodedRevokeInstruction } from './revoke.js';\nimport { decodeRevokeInstruction } from './revoke.js';\nimport type { DecodedSetAuthorityInstruction } from './setAuthority.js';\nimport { decodeSetAuthorityInstruction } from './setAuthority.js';\nimport type { DecodedSyncNativeInstruction } from './syncNative.js';\nimport { decodeSyncNativeInstruction } from './syncNative.js';\nimport type { DecodedThawAccountInstruction } from './thawAccount.js';\nimport { decodeThawAccountInstruction } from './thawAccount.js';\nimport type { DecodedTransferInstruction } from './transfer.js';\nimport { decodeTransferInstruction } from './transfer.js';\nimport type { DecodedTransferCheckedInstruction } from './transferChecked.js';\nimport { decodeTransferCheckedInstruction } from './transferChecked.js';\nimport { TokenInstruction } from './types.js';\nimport type { DecodedUiAmountToAmountInstruction } from './uiAmountToAmount.js';\nimport { decodeUiAmountToAmountInstruction } from './uiAmountToAmount.js';\n\n/** TODO: docs */\nexport type DecodedInstruction =\n    | DecodedInitializeMintInstruction\n    | DecodedInitializeAccountInstruction\n    | DecodedInitializeMultisigInstruction\n    | DecodedTransferInstruction\n    | DecodedApproveInstruction\n    | DecodedRevokeInstruction\n    | DecodedSetAuthorityInstruction\n    | DecodedMintToInstruction\n    | DecodedBurnInstruction\n    | DecodedCloseAccountInstruction\n    | DecodedFreezeAccountInstruction\n    | DecodedThawAccountInstruction\n    | DecodedTransferCheckedInstruction\n    | DecodedApproveCheckedInstruction\n    | DecodedMintToCheckedInstruction\n    | DecodedBurnCheckedInstruction\n    | DecodedInitializeAccount2Instruction\n    | DecodedSyncNativeInstruction\n    | DecodedInitializeAccount3Instruction\n    | DecodedInitializeMint2Instruction\n    | DecodedAmountToUiAmountInstruction\n    | DecodedUiAmountToAmountInstruction\n    // | DecodedInitializeMultisig2Instruction\n    // TODO: implement ^ and remove `never`\n    | never;\n\n/** TODO: docs */\nexport function decodeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInstruction {\n    if (!instruction.data.length) throw new TokenInvalidInstructionDataError();\n\n    const type = u8().decode(instruction.data);\n    if (type === TokenInstruction.InitializeMint) return decodeInitializeMintInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount) return decodeInitializeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMultisig)\n        return decodeInitializeMultisigInstruction(instruction, programId);\n    if (type === TokenInstruction.Transfer) return decodeTransferInstruction(instruction, programId);\n    if (type === TokenInstruction.Approve) return decodeApproveInstruction(instruction, programId);\n    if (type === TokenInstruction.Revoke) return decodeRevokeInstruction(instruction, programId);\n    if (type === TokenInstruction.SetAuthority) return decodeSetAuthorityInstruction(instruction, programId);\n    if (type === TokenInstruction.MintTo) return decodeMintToInstruction(instruction, programId);\n    if (type === TokenInstruction.Burn) return decodeBurnInstruction(instruction, programId);\n    if (type === TokenInstruction.CloseAccount) return decodeCloseAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.FreezeAccount) return decodeFreezeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.ThawAccount) return decodeThawAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.TransferChecked) return decodeTransferCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.ApproveChecked) return decodeApproveCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.MintToChecked) return decodeMintToCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.BurnChecked) return decodeBurnCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount2)\n        return decodeInitializeAccount2Instruction(instruction, programId);\n    if (type === TokenInstruction.SyncNative) return decodeSyncNativeInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount3)\n        return decodeInitializeAccount3Instruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMint2) return decodeInitializeMint2Instruction(instruction, programId);\n    if (type === TokenInstruction.AmountToUiAmount) return decodeAmountToUiAmountInstruction(instruction, programId);\n    if (type === TokenInstruction.UiAmountToAmount) return decodeUiAmountToAmountInstruction(instruction, programId);\n    // TODO: implement\n    if (type === TokenInstruction.InitializeMultisig2) throw new TokenInvalidInstructionTypeError();\n\n    throw new TokenInvalidInstructionTypeError();\n}\n\n/** TODO: docs */\nexport function isInitializeMintInstruction(decoded: DecodedInstruction): decoded is DecodedInitializeMintInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint;\n}\n\n/** TODO: docs */\nexport function isInitializeAccountInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport function isInitializeMultisigInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeMultisigInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMultisig;\n}\n\n/** TODO: docs */\nexport function isTransferInstruction(decoded: DecodedInstruction): decoded is DecodedTransferInstruction {\n    return decoded.data.instruction === TokenInstruction.Transfer;\n}\n\n/** TODO: docs */\nexport function isApproveInstruction(decoded: DecodedInstruction): decoded is DecodedApproveInstruction {\n    return decoded.data.instruction === TokenInstruction.Approve;\n}\n\n/** TODO: docs */\nexport function isRevokeInstruction(decoded: DecodedInstruction): decoded is DecodedRevokeInstruction {\n    return decoded.data.instruction === TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport function isSetAuthorityInstruction(decoded: DecodedInstruction): decoded is DecodedSetAuthorityInstruction {\n    return decoded.data.instruction === TokenInstruction.SetAuthority;\n}\n\n/** TODO: docs */\nexport function isMintToInstruction(decoded: DecodedInstruction): decoded is DecodedMintToInstruction {\n    return decoded.data.instruction === TokenInstruction.MintTo;\n}\n\n/** TODO: docs */\nexport function isBurnInstruction(decoded: DecodedInstruction): decoded is DecodedBurnInstruction {\n    return decoded.data.instruction === TokenInstruction.Burn;\n}\n\n/** TODO: docs */\nexport function isCloseAccountInstruction(decoded: DecodedInstruction): decoded is DecodedCloseAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport function isFreezeAccountInstruction(decoded: DecodedInstruction): decoded is DecodedFreezeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport function isThawAccountInstruction(decoded: DecodedInstruction): decoded is DecodedThawAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport function isTransferCheckedInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedTransferCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.TransferChecked;\n}\n\n/** TODO: docs */\nexport function isApproveCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedApproveCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.ApproveChecked;\n}\n\n/** TODO: docs */\nexport function isMintToCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedMintToCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.MintToChecked;\n}\n\n/** TODO: docs */\nexport function isBurnCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedBurnCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.BurnChecked;\n}\n\n/** TODO: docs */\nexport function isInitializeAccount2Instruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeAccount2Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount2;\n}\n\n/** TODO: docs */\nexport function isSyncNativeInstruction(decoded: DecodedInstruction): decoded is DecodedSyncNativeInstruction {\n    return decoded.data.instruction === TokenInstruction.SyncNative;\n}\n\n/** TODO: docs */\nexport function isInitializeAccount3Instruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeAccount3Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount3;\n}\n\n/** TODO: docs, implement */\n// export function isInitializeMultisig2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeMultisig2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeMultisig2;\n// }\n\n/** TODO: docs */\nexport function isInitializeMint2Instruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeMint2Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint2;\n}\n\n/** TODO: docs */\nexport function isAmountToUiAmountInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedAmountToUiAmountInstruction {\n    return decoded.data.instruction === TokenInstruction.AmountToUiAmount;\n}\n\n/** TODO: docs */\nexport function isUiamountToAmountInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedUiAmountToAmountInstruction {\n    return decoded.data.instruction === TokenInstruction.UiAmountToAmount;\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\nexport interface InitializeAccount2InstructionData {\n    instruction: TokenInstruction.InitializeAccount2;\n    owner: PublicKey;\n}\n\nexport const initializeAccount2InstructionData = struct<InitializeAccount2InstructionData>([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n\n/**\n * Construct an InitializeAccount2 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount2Instruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount2InstructionData.span);\n    initializeAccount2InstructionData.encode({ instruction: TokenInstruction.InitializeAccount2, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount2 instruction */\nexport interface DecodedInitializeAccount2Instruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount2;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount2Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeAccount2Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount2InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, rent },\n        data,\n    } = decodeInitializeAccount2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount2) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount2 instruction */\nexport interface DecodedInitializeAccount2InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount2InstructionUnchecked({\n    programId,\n    keys: [account, mint, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeAccount2InstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data: initializeAccount2InstructionData.decode(data),\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\nexport interface InitializeAccount3InstructionData {\n    instruction: TokenInstruction.InitializeAccount3;\n    owner: PublicKey;\n}\n\nexport const initializeAccount3InstructionData = struct<InitializeAccount3InstructionData>([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n\n/**\n * Construct an InitializeAccount3 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount3Instruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount3InstructionData.span);\n    initializeAccount3InstructionData.encode({ instruction: TokenInstruction.InitializeAccount3, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount3 instruction */\nexport interface DecodedInitializeAccount3Instruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount3;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount3 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount3Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeAccount3Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount3InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint },\n        data,\n    } = decodeInitializeAccount3InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount3) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount3 instruction */\nexport interface DecodedInitializeAccount3InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount3 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount3InstructionUnchecked({\n    programId,\n    keys: [account, mint],\n    data,\n}: TransactionInstruction): DecodedInitializeAccount3InstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data: initializeAccount3InstructionData.decode(data),\n    };\n}\n", "export {};\n//# sourceMappingURL=initializeMultisig2.js.map", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** Deserialized instruction for the initiation of an immutable owner account */\nexport interface InitializeImmutableOwnerInstructionData {\n    instruction: TokenInstruction.InitializeImmutableOwner;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeImmutableOwnerInstructionData = struct<InitializeImmutableOwnerInstructionData>([\n    u8('instruction'),\n]);\n\n/**\n * Construct an InitializeImmutableOwner instruction\n *\n * @param account           Immutable Owner Account\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeImmutableOwnerInstruction(\n    account: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeImmutableOwnerInstructionData.span);\n    initializeImmutableOwnerInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeImmutableOwner,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeImmutableOwner instruction */\nexport interface DecodedInitializeImmutableOwnerInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeImmutableOwner;\n    };\n}\n\n/**\n * Decode an InitializeImmutableOwner instruction and validate it\n *\n * @param instruction InitializeImmutableOwner instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeImmutableOwnerInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializeImmutableOwnerInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeImmutableOwnerInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account },\n        data,\n    } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeImmutableOwner) throw new TokenInvalidInstructionTypeError();\n    if (!account) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeImmutableOwner instruction */\nexport interface DecodedInitializeImmutableOwnerInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode an InitializeImmutableOwner instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeImmutableOwnerInstructionUnchecked({\n    programId,\n    keys: [account],\n    data,\n}: TransactionInstruction): DecodedInitializeImmutableOwnerInstructionUnchecked {\n    const { instruction } = initializeImmutableOwnerInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account: account,\n        },\n        data: {\n            instruction,\n        },\n    };\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** TODO: docs */\nexport interface InitializeMintCloseAuthorityInstructionData {\n    instruction: TokenInstruction.InitializeMintCloseAuthority;\n    closeAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const initializeMintCloseAuthorityInstructionData = struct<InitializeMintCloseAuthorityInstructionData>([\n    u8('instruction'),\n    new COptionPublicKeyLayout('closeAuthority'),\n]);\n\n/**\n * Construct an InitializeMintCloseAuthority instruction\n *\n * @param mint            Token mint account\n * @param closeAuthority  Optional authority that can close the mint\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintCloseAuthorityInstruction(\n    mint: PublicKey,\n    closeAuthority: PublicKey | null,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(34); // worst-case size\n    initializeMintCloseAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMintCloseAuthority,\n            closeAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMintCloseAuthorityInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeMintCloseAuthority instruction */\nexport interface DecodedInitializeMintCloseAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMintCloseAuthority;\n        closeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMintCloseAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializeMintCloseAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintCloseAuthorityInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMintCloseAuthority)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMintCloseAuthority instruction */\nexport interface DecodedInitializeMintCloseAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        closeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMintCloseAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeMintCloseAuthorityInstructionUnchecked {\n    const { instruction, closeAuthority } = initializeMintCloseAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            closeAuthority,\n        },\n    };\n}\n", "import { seq, struct, u16, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ReallocateInstructionData {\n    instruction: TokenInstruction.Reallocate;\n    extensionTypes: ExtensionType[];\n}\n\n/**\n * Construct a Reallocate instruction\n *\n * @param account        Address of the token account\n * @param payer          Address paying for the reallocation\n * @param extensionTypes Extensions to reallocate for\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createReallocateInstruction(\n    account: PublicKey,\n    payer: PublicKey,\n    extensionTypes: ExtensionType[],\n    owner: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const baseKeys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n    const keys = addSigners(baseKeys, owner, multiSigners);\n\n    const reallocateInstructionData = struct<ReallocateInstructionData>([\n        u8('instruction'),\n        seq(u16(), extensionTypes.length, 'extensionTypes'),\n    ]);\n    const data = Buffer.alloc(reallocateInstructionData.span);\n    reallocateInstructionData.encode({ instruction: TokenInstruction.Reallocate, extensionTypes }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** Deserialized instruction for the initiation of an immutable owner account */\nexport interface InitializeNonTransferableMintInstructionData {\n    instruction: TokenInstruction.InitializeNonTransferableMint;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeNonTransferableMintInstructionData = struct<InitializeNonTransferableMintInstructionData>([\n    u8('instruction'),\n]);\n\n/**\n * Construct an InitializeNonTransferableMint instruction\n *\n * @param mint           Mint Account to make non-transferable\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeNonTransferableMintInstruction(\n    mint: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeNonTransferableMintInstructionData.span);\n    initializeNonTransferableMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeNonTransferableMint,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n", "import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializePermanentDelegateInstructionData {\n    instruction: TokenInstruction.InitializePermanentDelegate;\n    delegate: PublicKey;\n}\n\n/** TODO: docs */\nexport const initializePermanentDelegateInstructionData = struct<InitializePermanentDelegateInstructionData>([\n    u8('instruction'),\n    publicKey('delegate'),\n]);\n\n/**\n * Construct an InitializePermanentDelegate instruction\n *\n * @param mint               Token mint account\n * @param permanentDelegate  Authority that may sign for `Transfer`s and `Burn`s on any account\n * @param programId          SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializePermanentDelegateInstruction(\n    mint: PublicKey,\n    permanentDelegate: PublicKey | null,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializePermanentDelegateInstructionData.span);\n    initializePermanentDelegateInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializePermanentDelegate,\n            delegate: permanentDelegate || new PublicKey(0),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializePermanentDelegate instruction */\nexport interface DecodedInitializePermanentDelegateInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializePermanentDelegate;\n        delegate: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializePermanentDelegate instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializePermanentDelegateInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializePermanentDelegateInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializePermanentDelegateInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializePermanentDelegate) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializePermanentDelegate instruction */\nexport interface DecodedInitializePermanentDelegateInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        delegate: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializePermanentDelegate instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializePermanentDelegateInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializePermanentDelegateInstructionUnchecked {\n    const { instruction, delegate } = initializePermanentDelegateInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            delegate,\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": ["TokenInstruction", "import_buffer_layout", "AccountType", "import_buffer_layout", "import_buffer_layout", "AccountState", "import_buffer_layout", "CpiGuardInstruction", "import_buffer_layout", "import_buffer_layout", "DefaultAccountStateInstruction", "import_buffer_layout", "publicKey", "mint", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "MemoTransferInstruction", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "PausableInstruction", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "ScaledUiAmountInstruction", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "TransferFeeInstruction", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "pubkey", "TransferHookInstruction", "ExtensionType", "ONE_IN_BASIS_POINTS", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "transaction", "import_buffer_layout", "error", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "AuthorityType", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "GroupMemberPointerInstruction", "import_buffer_layout", "GroupPointerInstruction", "import_buffer_layout", "import_buffer_layout", "InterestBearingMintInstruction", "import_buffer_layout", "MetadataPointerInstruction", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout", "import_buffer_layout"]
}
