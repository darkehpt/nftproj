import {
  Field,
  bool,
  createEmitInstruction,
  createInitializeInstruction,
  createRemoveKeyInstruction,
  createUpdateAuthorityInstruction,
  createUpdateFieldInstruction,
  fixCodecSize,
  fixEncoderSize,
  getBytesCodec,
  getBytesEncoder,
  getStructCodec,
  getStructEncoder,
  getTupleEncoder,
  getU64Codec,
  getU64Encoder,
  pack,
  publicKey,
  transformEncoder,
  u64,
  unpack
} from "./chunk-K5ZHJFTB.js";
import "./chunk-N5KMCSPD.js";
import {
  Keypair,
  PUBLIC_KEY_LENGTH,
  PublicKey,
  SYSVAR_RENT_PUBKEY,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  init_index_browser_esm,
  require_Layout,
  sendAndConfirmTransaction
} from "./chunk-O6DKOFK2.js";
import "./chunk-HF52HGV3.js";
import "./chunk-PQE6IUIT.js";
import "./chunk-3XCDBSY3.js";
import "./chunk-EE4U552T.js";
import "./chunk-RNC5BL54.js";
import "./chunk-PLEM2NPZ.js";
import {
  Buffer,
  __toESM,
  init_buffer,
  init_process
} from "./chunk-G24NP327.js";

// node_modules/@solana/spl-token/lib/esm/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/actions/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/actions/amountToUiAmount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/constants.js
init_process();
init_buffer();
init_index_browser_esm();
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
function programSupportsExtensions(programId) {
  if (programId.equals(TOKEN_PROGRAM_ID)) {
    return false;
  } else {
    return true;
  }
}

// node_modules/@solana/spl-token/lib/esm/instructions/amountToUiAmount.js
init_process();
init_buffer();
var import_buffer_layout = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/errors.js
init_process();
init_buffer();
var TokenError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var TokenAccountNotFoundError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
};
var TokenInvalidAccountError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountError";
  }
};
var TokenInvalidAccountDataError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountDataError";
  }
};
var TokenInvalidAccountOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
};
var TokenInvalidAccountSizeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
};
var TokenInvalidMintError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
};
var TokenInvalidOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidOwnerError";
  }
};
var TokenOwnerOffCurveError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenOwnerOffCurveError";
  }
};
var TokenInvalidInstructionProgramError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionProgramError";
  }
};
var TokenInvalidInstructionKeysError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionKeysError";
  }
};
var TokenInvalidInstructionDataError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionDataError";
  }
};
var TokenInvalidInstructionTypeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidInstructionTypeError";
  }
};
var TokenUnsupportedInstructionError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenUnsupportedInstructionError";
  }
};
var TokenTransferHookAccountNotFound = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookAccountNotFound";
  }
};
var TokenTransferHookInvalidSeed = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookInvalidSeed";
  }
};
var TokenTransferHookAccountDataNotFound = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookAccountDataNotFound";
  }
};
var TokenTransferHookInvalidPubkeyData = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookInvalidPubkeyData";
  }
};
var TokenTransferHookPubkeyDataTooSmall = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenTransferHookPubkeyDataTooSmall";
  }
};

// node_modules/@solana/spl-token/lib/esm/instructions/types.js
init_process();
init_buffer();
var TokenInstruction;
(function(TokenInstruction2) {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
  TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
  TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
  TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
  TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
  TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
  TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
  TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
  TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
  TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
  TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
  TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
  TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
  TokenInstruction2[TokenInstruction2["GroupPointerExtension"] = 40] = "GroupPointerExtension";
  TokenInstruction2[TokenInstruction2["GroupMemberPointerExtension"] = 41] = "GroupMemberPointerExtension";
  TokenInstruction2[TokenInstruction2["ScaledUiAmountExtension"] = 43] = "ScaledUiAmountExtension";
  TokenInstruction2[TokenInstruction2["PausableExtension"] = 44] = "PausableExtension";
})(TokenInstruction || (TokenInstruction = {}));

// node_modules/@solana/spl-token/lib/esm/instructions/amountToUiAmount.js
var amountToUiAmountInstructionData = (0, import_buffer_layout.struct)([
  (0, import_buffer_layout.u8)("instruction"),
  u64("amount")
]);
function createAmountToUiAmountInstruction(mint, amount, programId = TOKEN_PROGRAM_ID) {
  const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
  const data = Buffer.alloc(amountToUiAmountInstructionData.span);
  amountToUiAmountInstructionData.encode({
    instruction: TokenInstruction.AmountToUiAmount,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeAmountToUiAmountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== amountToUiAmountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint }, data } = decodeAmountToUiAmountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.AmountToUiAmount)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint
    },
    data
  };
}
function decodeAmountToUiAmountInstructionUnchecked({ programId, keys: [mint], data }) {
  return {
    programId,
    keys: {
      mint
    },
    data: amountToUiAmountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/state/mint.js
init_process();
init_buffer();
var import_buffer_layout28 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/accountType.js
init_process();
init_buffer();
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
  AccountType2[AccountType2["Mint"] = 1] = "Mint";
  AccountType2[AccountType2["Account"] = 2] = "Account";
})(AccountType || (AccountType = {}));
var ACCOUNT_TYPE_SIZE = 1;

// node_modules/@solana/spl-token/lib/esm/extensions/extensionType.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/state/account.js
init_process();
init_buffer();
var import_buffer_layout3 = __toESM(require_Layout(), 1);

// node_modules/@solana/spl-token/lib/esm/state/multisig.js
init_process();
init_buffer();
var import_buffer_layout2 = __toESM(require_Layout(), 1);
var MultisigLayout = (0, import_buffer_layout2.struct)([
  (0, import_buffer_layout2.u8)("m"),
  (0, import_buffer_layout2.u8)("n"),
  bool("isInitialized"),
  publicKey("signer1"),
  publicKey("signer2"),
  publicKey("signer3"),
  publicKey("signer4"),
  publicKey("signer5"),
  publicKey("signer6"),
  publicKey("signer7"),
  publicKey("signer8"),
  publicKey("signer9"),
  publicKey("signer10"),
  publicKey("signer11")
]);
var MULTISIG_SIZE = MultisigLayout.span;
async function getMultisig(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  return unpackMultisig(address, info, programId);
}
function unpackMultisig(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length != MULTISIG_SIZE)
    throw new TokenInvalidAccountSizeError();
  const multisig = MultisigLayout.decode(info.data);
  return { address, ...multisig };
}
async function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
  return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);
}

// node_modules/@solana/spl-token/lib/esm/state/account.js
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout3.struct)([
  publicKey("mint"),
  publicKey("owner"),
  u64("amount"),
  (0, import_buffer_layout3.u32)("delegateOption"),
  publicKey("delegate"),
  (0, import_buffer_layout3.u8)("state"),
  (0, import_buffer_layout3.u32)("isNativeOption"),
  u64("isNative"),
  u64("delegatedAmount"),
  (0, import_buffer_layout3.u32)("closeAuthorityOption"),
  publicKey("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;
async function getAccount(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  return unpackAccount(address, info, programId);
}
async function getMultipleAccounts(connection, addresses, commitment, programId = TOKEN_PROGRAM_ID) {
  const infos = await connection.getMultipleAccountsInfo(addresses, commitment);
  return addresses.map((address, i) => unpackAccount(address, infos[i], programId));
}
async function getMinimumBalanceForRentExemptAccount(connection, commitment) {
  return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);
}
async function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {
  const accountLen = getAccountLen(extensions);
  return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);
}
function unpackAccount(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < ACCOUNT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > ACCOUNT_SIZE) {
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Account)
      throw new TokenInvalidAccountError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mint: rawAccount.mint,
    owner: rawAccount.owner,
    amount: rawAccount.amount,
    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
    delegatedAmount: rawAccount.delegatedAmount,
    isInitialized: rawAccount.state !== AccountState.Uninitialized,
    isFrozen: rawAccount.state === AccountState.Frozen,
    isNative: !!rawAccount.isNativeOption,
    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
    tlvData
  };
}

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/actions/internal.js
init_process();
init_buffer();
init_index_browser_esm();
function getSigners(signerOrMultisig, multiSigners) {
  return signerOrMultisig instanceof PublicKey ? [signerOrMultisig, multiSigners] : [signerOrMultisig.publicKey, [signerOrMultisig]];
}

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/instructions.js
init_process();
init_buffer();
var import_buffer_layout4 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/internal.js
init_process();
init_buffer();
init_index_browser_esm();
function addSigners(keys, ownerOrAuthority, multiSigners) {
  if (multiSigners.length) {
    keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
    for (const signer of multiSigners) {
      keys.push({
        pubkey: signer instanceof PublicKey ? signer : signer.publicKey,
        isSigner: true,
        isWritable: false
      });
    }
  } else {
    keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
  }
  return keys;
}

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/instructions.js
var CpiGuardInstruction;
(function(CpiGuardInstruction2) {
  CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
  CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
})(CpiGuardInstruction || (CpiGuardInstruction = {}));
var cpiGuardInstructionData = (0, import_buffer_layout4.struct)([(0, import_buffer_layout4.u8)("instruction"), (0, import_buffer_layout4.u8)("cpiGuardInstruction")]);
function createEnableCpiGuardInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);
}
function createDisableCpiGuardInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);
}
function createCpiGuardInstruction(cpiGuardInstruction, account, authority, multiSigners, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(cpiGuardInstructionData.span);
  cpiGuardInstructionData.encode({
    instruction: TokenInstruction.CpiGuardExtension,
    cpiGuardInstruction
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/actions.js
async function enableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createEnableCpiGuardInstruction(account, ownerPublicKey, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function disableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createDisableCpiGuardInstruction(account, ownerPublicKey, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/state.js
init_process();
init_buffer();
var import_buffer_layout5 = __toESM(require_Layout(), 1);
var CpiGuardLayout = (0, import_buffer_layout5.struct)([bool("lockCpi")]);
var CPI_GUARD_SIZE = CpiGuardLayout.span;
function getCpiGuard(account) {
  const extensionData = getExtensionData(ExtensionType.CpiGuard, account.tlvData);
  if (extensionData !== null) {
    return CpiGuardLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/instructions.js
init_process();
init_buffer();
var import_buffer_layout6 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var DefaultAccountStateInstruction;
(function(DefaultAccountStateInstruction2) {
  DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
  DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
})(DefaultAccountStateInstruction || (DefaultAccountStateInstruction = {}));
var defaultAccountStateInstructionData = (0, import_buffer_layout6.struct)([
  (0, import_buffer_layout6.u8)("instruction"),
  (0, import_buffer_layout6.u8)("defaultAccountStateInstruction"),
  (0, import_buffer_layout6.u8)("accountState")
]);
function createInitializeDefaultAccountStateInstruction(mint, accountState, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(defaultAccountStateInstructionData.span);
  defaultAccountStateInstructionData.encode({
    instruction: TokenInstruction.DefaultAccountStateExtension,
    defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,
    accountState
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function createUpdateDefaultAccountStateInstruction(mint, accountState, freezeAuthority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);
  const data = Buffer.alloc(defaultAccountStateInstructionData.span);
  defaultAccountStateInstructionData.encode({
    instruction: TokenInstruction.DefaultAccountStateExtension,
    defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,
    accountState
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/actions.js
async function initializeDefaultAccountState(connection, payer, mint, state, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const transaction = new Transaction().add(createInitializeDefaultAccountStateInstruction(mint, state, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
}
async function updateDefaultAccountState(connection, payer, mint, state, freezeAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [freezeAuthorityPublicKey, signers] = getSigners(freezeAuthority, multiSigners);
  const transaction = new Transaction().add(createUpdateDefaultAccountStateInstruction(mint, state, freezeAuthorityPublicKey, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/state.js
init_process();
init_buffer();
var import_buffer_layout7 = __toESM(require_Layout(), 1);
var DefaultAccountStateLayout = (0, import_buffer_layout7.struct)([(0, import_buffer_layout7.u8)("state")]);
var DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;
function getDefaultAccountState(mint) {
  const extensionData = getExtensionData(ExtensionType.DefaultAccountState, mint.tlvData);
  if (extensionData !== null) {
    return DefaultAccountStateLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/tokenGroup/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/tokenGroup/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token-group/lib/esm/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token-group/lib/esm/errors.js
init_process();
init_buffer();

// node_modules/@solana/spl-token-group/lib/esm/instruction.js
init_process();
init_buffer();
init_index_browser_esm();
function getInstructionEncoder(discriminator, dataEncoder) {
  return transformEncoder(getTupleEncoder([getBytesEncoder(), dataEncoder]), (data) => [
    discriminator,
    data
  ]);
}
function getPublicKeyEncoder() {
  return transformEncoder(fixEncoderSize(getBytesEncoder(), 32), (publicKey2) => publicKey2.toBytes());
}
function createInitializeGroupInstruction(args) {
  const { programId, group, mint, mintAuthority, updateAuthority, maxSize } = args;
  return new TransactionInstruction({
    programId,
    keys: [
      { isSigner: false, isWritable: true, pubkey: group },
      { isSigner: false, isWritable: false, pubkey: mint },
      { isSigner: true, isWritable: false, pubkey: mintAuthority }
    ],
    data: Buffer.from(getInstructionEncoder(new Uint8Array([
      /* await splDiscriminate('spl_token_group_interface:initialize_token_group') */
      121,
      113,
      108,
      39,
      54,
      51,
      0,
      4
    ]), getStructEncoder([
      ["updateAuthority", getPublicKeyEncoder()],
      ["maxSize", getU64Encoder()]
    ])).encode({ updateAuthority: updateAuthority ?? SystemProgram.programId, maxSize }))
  });
}
function createUpdateGroupMaxSizeInstruction(args) {
  const { programId, group, updateAuthority, maxSize } = args;
  return new TransactionInstruction({
    programId,
    keys: [
      { isSigner: false, isWritable: true, pubkey: group },
      { isSigner: true, isWritable: false, pubkey: updateAuthority }
    ],
    data: Buffer.from(getInstructionEncoder(new Uint8Array([
      /* await splDiscriminate('spl_token_group_interface:update_group_max_size') */
      108,
      37,
      171,
      143,
      248,
      30,
      18,
      110
    ]), getStructEncoder([["maxSize", getU64Encoder()]])).encode({ maxSize }))
  });
}
function createUpdateGroupAuthorityInstruction(args) {
  const { programId, group, currentAuthority, newAuthority } = args;
  return new TransactionInstruction({
    programId,
    keys: [
      { isSigner: false, isWritable: true, pubkey: group },
      { isSigner: true, isWritable: false, pubkey: currentAuthority }
    ],
    data: Buffer.from(getInstructionEncoder(new Uint8Array([
      /* await splDiscriminate('spl_token_group_interface:update_authority') */
      161,
      105,
      88,
      1,
      237,
      221,
      216,
      203
    ]), getStructEncoder([["newAuthority", getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority ?? SystemProgram.programId }))
  });
}
function createInitializeMemberInstruction(args) {
  const { programId, member, memberMint, memberMintAuthority, group, groupUpdateAuthority } = args;
  return new TransactionInstruction({
    programId,
    keys: [
      { isSigner: false, isWritable: true, pubkey: member },
      { isSigner: false, isWritable: false, pubkey: memberMint },
      { isSigner: true, isWritable: false, pubkey: memberMintAuthority },
      { isSigner: false, isWritable: true, pubkey: group },
      { isSigner: true, isWritable: false, pubkey: groupUpdateAuthority }
    ],
    data: Buffer.from(getInstructionEncoder(new Uint8Array([
      /* await splDiscriminate('spl_token_group_interface:initialize_member') */
      152,
      32,
      222,
      176,
      223,
      237,
      116,
      134
    ]), getStructEncoder([])).encode({}))
  });
}

// node_modules/@solana/spl-token-group/lib/esm/state/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token-group/lib/esm/state/tokenGroup.js
init_process();
init_buffer();
init_index_browser_esm();
var tokenGroupCodec = getStructCodec([
  ["updateAuthority", fixCodecSize(getBytesCodec(), 32)],
  ["mint", fixCodecSize(getBytesCodec(), 32)],
  ["size", getU64Codec()],
  ["maxSize", getU64Codec()]
]);
var TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;
function isNonePubkey(buffer) {
  for (let i = 0; i < buffer.length; i++) {
    if (buffer[i] !== 0) {
      return false;
    }
  }
  return true;
}
function unpackTokenGroup(buffer) {
  const data = tokenGroupCodec.decode(buffer);
  return isNonePubkey(data.updateAuthority) ? {
    mint: new PublicKey(data.mint),
    size: data.size,
    maxSize: data.maxSize
  } : {
    updateAuthority: new PublicKey(data.updateAuthority),
    mint: new PublicKey(data.mint),
    size: data.size,
    maxSize: data.maxSize
  };
}

// node_modules/@solana/spl-token-group/lib/esm/state/tokenGroupMember.js
init_process();
init_buffer();
init_index_browser_esm();
var tokenGroupMemberCodec = getStructCodec([
  ["mint", fixCodecSize(getBytesCodec(), 32)],
  ["group", fixCodecSize(getBytesCodec(), 32)],
  ["memberNumber", getU64Codec()]
]);
var TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize;
function unpackTokenGroupMember(buffer) {
  const data = tokenGroupMemberCodec.decode(buffer);
  return {
    mint: new PublicKey(data.mint),
    group: new PublicKey(data.group),
    memberNumber: data.memberNumber
  };
}

// node_modules/@solana/spl-token/lib/esm/extensions/tokenGroup/actions.js
async function tokenGroupInitializeGroup(connection, payer, mint, mintAuthority, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);
  const transaction = new Transaction().add(createInitializeGroupInstruction({
    programId,
    group: mint,
    mint,
    mintAuthority: mintAuthorityPublicKey,
    updateAuthority,
    maxSize
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenGroupInitializeGroupWithRentTransfer(connection, payer, mint, mintAuthority, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);
  const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_SIZE);
  const transaction = new Transaction().add(SystemProgram.transfer({
    fromPubkey: payer.publicKey,
    toPubkey: mint,
    lamports
  }), createInitializeGroupInstruction({
    programId,
    group: mint,
    mint,
    mintAuthority: mintAuthorityPublicKey,
    updateAuthority,
    maxSize
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenGroupUpdateGroupMaxSize(connection, payer, mint, updateAuthority, maxSize, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);
  const transaction = new Transaction().add(createUpdateGroupMaxSizeInstruction({
    programId,
    group: mint,
    updateAuthority: updateAuthorityPublicKey,
    maxSize
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenGroupUpdateGroupAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);
  const transaction = new Transaction().add(createUpdateGroupAuthorityInstruction({
    programId,
    group: mint,
    currentAuthority: updateAuthorityPublicKey,
    newAuthority
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenGroupMemberInitialize(connection, payer, mint, mintAuthority, group, groupUpdateAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);
  const transaction = new Transaction().add(createInitializeMemberInstruction({
    programId,
    member: mint,
    memberMint: mint,
    memberMintAuthority: mintAuthorityPublicKey,
    group,
    groupUpdateAuthority
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenGroupMemberInitializeWithRentTransfer(connection, payer, mint, mintAuthority, group, groupUpdateAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);
  const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_MEMBER_SIZE);
  const transaction = new Transaction().add(SystemProgram.transfer({
    fromPubkey: payer.publicKey,
    toPubkey: mint,
    lamports
  }), createInitializeMemberInstruction({
    programId,
    member: mint,
    memberMint: mint,
    memberMintAuthority: mintAuthorityPublicKey,
    group,
    groupUpdateAuthority
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/tokenGroup/state.js
init_process();
init_buffer();
init_index_browser_esm();
function getTokenGroupState(mint) {
  const extensionData = getExtensionData(ExtensionType.TokenGroup, mint.tlvData);
  if (extensionData !== null) {
    const { updateAuthority, mint: mint2, size, maxSize } = unpackTokenGroup(extensionData);
    return {
      updateAuthority: (updateAuthority == null ? void 0 : updateAuthority.equals(PublicKey.default)) ? void 0 : updateAuthority,
      mint: mint2,
      size,
      maxSize
    };
  } else {
    return null;
  }
}
function getTokenGroupMemberState(mint) {
  const extensionData = getExtensionData(ExtensionType.TokenGroupMember, mint.tlvData);
  if (extensionData !== null) {
    const { mint: mint2, group, memberNumber } = unpackTokenGroupMember(extensionData);
    return {
      mint: mint2,
      group,
      memberNumber
    };
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/groupMemberPointer/state.js
init_process();
init_buffer();
var import_buffer_layout8 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var GroupMemberPointerLayout = (0, import_buffer_layout8.struct)([
  publicKey("authority"),
  publicKey("memberAddress")
]);
var GROUP_MEMBER_POINTER_SIZE = GroupMemberPointerLayout.span;
function getGroupMemberPointerState(mint) {
  const extensionData = getExtensionData(ExtensionType.GroupMemberPointer, mint.tlvData);
  if (extensionData !== null) {
    const { authority, memberAddress } = GroupMemberPointerLayout.decode(extensionData);
    return {
      authority: authority.equals(PublicKey.default) ? null : authority,
      memberAddress: memberAddress.equals(PublicKey.default) ? null : memberAddress
    };
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/groupPointer/state.js
init_process();
init_buffer();
var import_buffer_layout9 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var GroupPointerLayout = (0, import_buffer_layout9.struct)([
  publicKey("authority"),
  publicKey("groupAddress")
]);
var GROUP_POINTER_SIZE = GroupPointerLayout.span;
function getGroupPointerState(mint) {
  const extensionData = getExtensionData(ExtensionType.GroupPointer, mint.tlvData);
  if (extensionData !== null) {
    const { authority, groupAddress } = GroupPointerLayout.decode(extensionData);
    return {
      authority: authority.equals(PublicKey.default) ? null : authority,
      groupAddress: groupAddress.equals(PublicKey.default) ? null : groupAddress
    };
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/immutableOwner.js
init_process();
init_buffer();
var import_buffer_layout10 = __toESM(require_Layout(), 1);
var ImmutableOwnerLayout = (0, import_buffer_layout10.struct)([]);
var IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span;
function getImmutableOwner(account) {
  const extensionData = getExtensionData(ExtensionType.ImmutableOwner, account.tlvData);
  if (extensionData !== null) {
    return ImmutableOwnerLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/state.js
init_process();
init_buffer();
var import_buffer_layout11 = __toESM(require_Layout(), 1);
var InterestBearingMintConfigStateLayout = (0, import_buffer_layout11.struct)([
  publicKey("rateAuthority"),
  (0, import_buffer_layout11.ns64)("initializationTimestamp"),
  (0, import_buffer_layout11.s16)("preUpdateAverageRate"),
  (0, import_buffer_layout11.ns64)("lastUpdateTimestamp"),
  (0, import_buffer_layout11.s16)("currentRate")
]);
var INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span;
function getInterestBearingMintConfigState(mint) {
  const extensionData = getExtensionData(ExtensionType.InterestBearingConfig, mint.tlvData);
  if (extensionData !== null) {
    return InterestBearingMintConfigStateLayout.decode(extensionData);
  }
  return null;
}

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/instructions.js
init_process();
init_buffer();
var import_buffer_layout12 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var MemoTransferInstruction;
(function(MemoTransferInstruction2) {
  MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
  MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
})(MemoTransferInstruction || (MemoTransferInstruction = {}));
var memoTransferInstructionData = (0, import_buffer_layout12.struct)([
  (0, import_buffer_layout12.u8)("instruction"),
  (0, import_buffer_layout12.u8)("memoTransferInstruction")
]);
function createEnableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);
}
function createDisableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);
}
function createMemoTransferInstruction(memoTransferInstruction, account, authority, multiSigners, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(memoTransferInstructionData.span);
  memoTransferInstructionData.encode({
    instruction: TokenInstruction.MemoTransferExtension,
    memoTransferInstruction
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/actions.js
async function enableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createEnableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function disableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createDisableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/state.js
init_process();
init_buffer();
var import_buffer_layout13 = __toESM(require_Layout(), 1);
var MemoTransferLayout = (0, import_buffer_layout13.struct)([bool("requireIncomingTransferMemos")]);
var MEMO_TRANSFER_SIZE = MemoTransferLayout.span;
function getMemoTransfer(account) {
  const extensionData = getExtensionData(ExtensionType.MemoTransfer, account.tlvData);
  if (extensionData !== null) {
    return MemoTransferLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/metadataPointer/state.js
init_process();
init_buffer();
var import_buffer_layout14 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var MetadataPointerLayout = (0, import_buffer_layout14.struct)([
  publicKey("authority"),
  publicKey("metadataAddress")
]);
var METADATA_POINTER_SIZE = MetadataPointerLayout.span;
function getMetadataPointerState(mint) {
  const extensionData = getExtensionData(ExtensionType.MetadataPointer, mint.tlvData);
  if (extensionData !== null) {
    const { authority, metadataAddress } = MetadataPointerLayout.decode(extensionData);
    return {
      authority: authority.equals(PublicKey.default) ? null : authority,
      metadataAddress: metadataAddress.equals(PublicKey.default) ? null : metadataAddress
    };
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/mintCloseAuthority.js
init_process();
init_buffer();
var import_buffer_layout15 = __toESM(require_Layout(), 1);
var MintCloseAuthorityLayout = (0, import_buffer_layout15.struct)([publicKey("closeAuthority")]);
var MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span;
function getMintCloseAuthority(mint) {
  const extensionData = getExtensionData(ExtensionType.MintCloseAuthority, mint.tlvData);
  if (extensionData !== null) {
    return MintCloseAuthorityLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/nonTransferable.js
init_process();
init_buffer();
var import_buffer_layout16 = __toESM(require_Layout(), 1);
var NonTransferableLayout = (0, import_buffer_layout16.struct)([]);
var NON_TRANSFERABLE_SIZE = NonTransferableLayout.span;
var NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span;
function getNonTransferable(mint) {
  const extensionData = getExtensionData(ExtensionType.NonTransferable, mint.tlvData);
  if (extensionData !== null) {
    return NonTransferableLayout.decode(extensionData);
  } else {
    return null;
  }
}
function getNonTransferableAccount(account) {
  const extensionData = getExtensionData(ExtensionType.NonTransferableAccount, account.tlvData);
  if (extensionData !== null) {
    return NonTransferableLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/pausable/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/pausable/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/pausable/instructions.js
init_process();
init_buffer();
var import_buffer_layout17 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var PausableInstruction;
(function(PausableInstruction2) {
  PausableInstruction2[PausableInstruction2["Initialize"] = 0] = "Initialize";
  PausableInstruction2[PausableInstruction2["Pause"] = 1] = "Pause";
  PausableInstruction2[PausableInstruction2["Resume"] = 2] = "Resume";
})(PausableInstruction || (PausableInstruction = {}));
var initializePausableConfigInstructionData = (0, import_buffer_layout17.struct)([
  (0, import_buffer_layout17.u8)("instruction"),
  (0, import_buffer_layout17.u8)("pausableInstruction"),
  publicKey("authority")
]);
function createInitializePausableConfigInstruction(mint, authority, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializePausableConfigInstructionData.span);
  initializePausableConfigInstructionData.encode({
    instruction: TokenInstruction.PausableExtension,
    pausableInstruction: PausableInstruction.Initialize,
    authority: authority ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var pauseInstructionData = (0, import_buffer_layout17.struct)([(0, import_buffer_layout17.u8)("instruction"), (0, import_buffer_layout17.u8)("pausableInstruction")]);
function createPauseInstruction(mint, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(pauseInstructionData.span);
  pauseInstructionData.encode({
    instruction: TokenInstruction.PausableExtension,
    pausableInstruction: PausableInstruction.Pause
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var resumeInstructionData = (0, import_buffer_layout17.struct)([(0, import_buffer_layout17.u8)("instruction"), (0, import_buffer_layout17.u8)("pausableInstruction")]);
function createResumeInstruction(mint, authority, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(resumeInstructionData.span);
  resumeInstructionData.encode({
    instruction: TokenInstruction.PausableExtension,
    pausableInstruction: PausableInstruction.Resume
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/pausable/actions.js
async function pause(connection, payer, mint, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createPauseInstruction(mint, ownerPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function resume(connection, payer, mint, owner, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createResumeInstruction(mint, ownerPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/pausable/state.js
init_process();
init_buffer();
var import_buffer_layout18 = __toESM(require_Layout(), 1);
var PausableConfigLayout = (0, import_buffer_layout18.struct)([publicKey("authority"), bool("paused")]);
var PAUSABLE_CONFIG_SIZE = PausableConfigLayout.span;
function getPausableConfig(mint) {
  const extensionData = getExtensionData(ExtensionType.PausableConfig, mint.tlvData);
  if (extensionData !== null) {
    return PausableConfigLayout.decode(extensionData);
  } else {
    return null;
  }
}
var PausableAccountLayout = (0, import_buffer_layout18.struct)([]);
var PAUSABLE_ACCOUNT_SIZE = PausableAccountLayout.span;
function getPausableAccount(account) {
  const extensionData = getExtensionData(ExtensionType.PausableAccount, account.tlvData);
  if (extensionData !== null) {
    return PausableAccountLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/permanentDelegate.js
init_process();
init_buffer();
var import_buffer_layout19 = __toESM(require_Layout(), 1);
var PermanentDelegateLayout = (0, import_buffer_layout19.struct)([publicKey("delegate")]);
var PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span;
function getPermanentDelegate(mint) {
  const extensionData = getExtensionData(ExtensionType.PermanentDelegate, mint.tlvData);
  if (extensionData !== null) {
    return PermanentDelegateLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/scaledUiAmount/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/scaledUiAmount/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/scaledUiAmount/instructions.js
init_process();
init_buffer();
var import_buffer_layout20 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var ScaledUiAmountInstruction;
(function(ScaledUiAmountInstruction2) {
  ScaledUiAmountInstruction2[ScaledUiAmountInstruction2["Initialize"] = 0] = "Initialize";
  ScaledUiAmountInstruction2[ScaledUiAmountInstruction2["UpdateMultiplier"] = 1] = "UpdateMultiplier";
})(ScaledUiAmountInstruction || (ScaledUiAmountInstruction = {}));
var initializeScaledUiAmountConfigInstructionData = (0, import_buffer_layout20.struct)([
  (0, import_buffer_layout20.u8)("instruction"),
  (0, import_buffer_layout20.u8)("scaledUiAmountInstruction"),
  publicKey("authority"),
  (0, import_buffer_layout20.f64)("multiplier")
]);
function createInitializeScaledUiAmountConfigInstruction(mint, authority, multiplier, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeScaledUiAmountConfigInstructionData.span);
  initializeScaledUiAmountConfigInstructionData.encode({
    instruction: TokenInstruction.ScaledUiAmountExtension,
    scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize,
    authority: authority ?? PublicKey.default,
    multiplier
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var updateMultiplierData = (0, import_buffer_layout20.struct)([
  (0, import_buffer_layout20.u8)("instruction"),
  (0, import_buffer_layout20.u8)("scaledUiAmountInstruction"),
  (0, import_buffer_layout20.f64)("multiplier"),
  u64("effectiveTimestamp")
]);
function createUpdateMultiplierDataInstruction(mint, authority, multiplier, effectiveTimestamp, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(updateMultiplierData.span);
  updateMultiplierData.encode({
    instruction: TokenInstruction.ScaledUiAmountExtension,
    scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier,
    multiplier,
    effectiveTimestamp
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/scaledUiAmount/actions.js
async function updateMultiplier(connection, payer, mint, owner, multiplier, effectiveTimestamp, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createUpdateMultiplierDataInstruction(mint, ownerPublicKey, multiplier, effectiveTimestamp, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/scaledUiAmount/state.js
init_process();
init_buffer();
var import_buffer_layout21 = __toESM(require_Layout(), 1);
var ScaledUiAmountConfigLayout = (0, import_buffer_layout21.struct)([
  publicKey("authority"),
  (0, import_buffer_layout21.f64)("multiplier"),
  u64("newMultiplierEffectiveTimestamp"),
  (0, import_buffer_layout21.f64)("newMultiplier")
]);
var SCALED_UI_AMOUNT_CONFIG_SIZE = ScaledUiAmountConfigLayout.span;
function getScaledUiAmountConfig(mint) {
  const extensionData = getExtensionData(ExtensionType.ScaledUiAmountConfig, mint.tlvData);
  if (extensionData !== null) {
    return ScaledUiAmountConfigLayout.decode(extensionData);
  }
  return null;
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/instructions.js
init_process();
init_buffer();
var import_buffer_layout23 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/serialization.js
init_process();
init_buffer();
var import_buffer_layout22 = __toESM(require_Layout(), 1);
var COptionPublicKeyLayout = class extends import_buffer_layout22.Layout {
  constructor(property) {
    super(-1, property);
    this.publicKeyLayout = publicKey();
  }
  decode(buffer, offset = 0) {
    const option = buffer[offset];
    if (option === 0) {
      return null;
    }
    return this.publicKeyLayout.decode(buffer, offset + 1);
  }
  encode(src, buffer, offset = 0) {
    if (src === null) {
      buffer[offset] = 0;
      return 1;
    } else {
      buffer[offset] = 1;
      this.publicKeyLayout.encode(src, buffer, offset + 1);
      return 33;
    }
  }
  getSpan(buffer, offset = 0) {
    if (buffer) {
      const option = buffer[offset];
      return option === 0 ? 1 : 1 + this.publicKeyLayout.span;
    }
    throw new RangeError("Buffer must be provided");
  }
};

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/instructions.js
var TransferFeeInstruction;
(function(TransferFeeInstruction2) {
  TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
  TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
  TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
  TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
  TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
  TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
})(TransferFeeInstruction || (TransferFeeInstruction = {}));
var initializeTransferFeeConfigInstructionData = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u8)("instruction"),
  (0, import_buffer_layout23.u8)("transferFeeInstruction"),
  new COptionPublicKeyLayout("transferFeeConfigAuthority"),
  new COptionPublicKeyLayout("withdrawWithheldAuthority"),
  (0, import_buffer_layout23.u16)("transferFeeBasisPoints"),
  u64("maximumFee")
]);
function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(78);
  initializeTransferFeeConfigInstructionData.encode({
    instruction: TokenInstruction.TransferFeeExtension,
    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,
    transferFeeConfigAuthority,
    withdrawWithheldAuthority,
    transferFeeBasisPoints,
    maximumFee
  }, data);
  return new TransactionInstruction({
    keys,
    programId,
    data: data.subarray(0, initializeTransferFeeConfigInstructionData.getSpan(data))
  });
}
function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeTransferFeeConfigInstructionData.getSpan(instruction.data))
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint }, data } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint
    },
    data
  };
}
function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data }) {
  const { instruction, transferFeeInstruction, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee } = initializeTransferFeeConfigInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint
    },
    data: {
      instruction,
      transferFeeInstruction,
      transferFeeConfigAuthority,
      withdrawWithheldAuthority,
      transferFeeBasisPoints,
      maximumFee
    }
  };
}
var transferCheckedWithFeeInstructionData = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u8)("instruction"),
  (0, import_buffer_layout23.u8)("transferFeeInstruction"),
  u64("amount"),
  (0, import_buffer_layout23.u8)("decimals"),
  u64("fee")
]);
function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);
  transferCheckedWithFeeInstructionData.encode({
    instruction: TokenInstruction.TransferFeeExtension,
    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,
    amount,
    decimals,
    fee
  }, data);
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeTransferCheckedWithFeeInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { source, mint, destination, authority, signers }, data } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      source,
      mint,
      destination,
      authority,
      signers: signers ? signers : null
    },
    data
  };
}
function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data }) {
  const { instruction, transferFeeInstruction, amount, decimals, fee } = transferCheckedWithFeeInstructionData.decode(data);
  return {
    programId,
    keys: {
      source,
      mint,
      destination,
      authority,
      signers
    },
    data: {
      instruction,
      transferFeeInstruction,
      amount,
      decimals,
      fee
    }
  };
}
var withdrawWithheldTokensFromMintInstructionData = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u8)("instruction"),
  (0, import_buffer_layout23.u8)("transferFeeInstruction")
]);
function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);
  withdrawWithheldTokensFromMintInstructionData.encode({
    instruction: TokenInstruction.TransferFeeExtension,
    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint
  }, data);
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, signers);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, destination, authority, signers }, data } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      signers: signers ? signers : null
    },
    data
  };
}
function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data }) {
  const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      signers
    },
    data: {
      instruction,
      transferFeeInstruction
    }
  };
}
var withdrawWithheldTokensFromAccountsInstructionData = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u8)("instruction"),
  (0, import_buffer_layout23.u8)("transferFeeInstruction"),
  (0, import_buffer_layout23.u8)("numTokenAccounts")
]);
function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);
  withdrawWithheldTokensFromAccountsInstructionData.encode({
    instruction: TokenInstruction.TransferFeeExtension,
    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,
    numTokenAccounts: sources.length
  }, data);
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, signers);
  for (const source of sources) {
    keys.push({ pubkey: source, isSigner: false, isWritable: true });
  }
  return new TransactionInstruction({ keys, programId, data });
}
function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, destination, authority, signers, sources }, data } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      signers: signers ? signers : null,
      sources: sources ? sources : null
    },
    data
  };
}
function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data }) {
  const { instruction, transferFeeInstruction, numTokenAccounts } = withdrawWithheldTokensFromAccountsInstructionData.decode(data);
  const [mint, destination, authority, signers, sources] = [
    keys[0],
    keys[1],
    keys[2],
    keys.slice(3, 3 + numTokenAccounts),
    keys.slice(-1 * numTokenAccounts)
  ];
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      signers,
      sources
    },
    data: {
      instruction,
      transferFeeInstruction,
      numTokenAccounts
    }
  };
}
var harvestWithheldTokensToMintInstructionData = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u8)("instruction"),
  (0, import_buffer_layout23.u8)("transferFeeInstruction")
]);
function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);
  harvestWithheldTokensToMintInstructionData.encode({
    instruction: TokenInstruction.TransferFeeExtension,
    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint
  }, data);
  const keys = [];
  keys.push({ pubkey: mint, isSigner: false, isWritable: true });
  for (const source of sources) {
    keys.push({ pubkey: source, isSigner: false, isWritable: true });
  }
  return new TransactionInstruction({ keys, programId, data });
}
function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, sources }, data } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      sources
    },
    data
  };
}
function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data }) {
  const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint,
      sources
    },
    data: {
      instruction,
      transferFeeInstruction
    }
  };
}
var setTransferFeeInstructionData = (0, import_buffer_layout23.struct)([
  (0, import_buffer_layout23.u8)("instruction"),
  (0, import_buffer_layout23.u8)("transferFeeInstruction"),
  (0, import_buffer_layout23.u16)("transferFeeBasisPoints"),
  u64("maximumFee")
]);
function createSetTransferFeeInstruction(mint, authority, signers, transferFeeBasisPoints, maximumFee, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const data = Buffer.alloc(setTransferFeeInstructionData.span);
  setTransferFeeInstructionData.encode({
    instruction: TokenInstruction.TransferFeeExtension,
    transferFeeInstruction: TransferFeeInstruction.SetTransferFee,
    transferFeeBasisPoints,
    maximumFee
  }, data);
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, signers);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeSetTransferFeeInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== setTransferFeeInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, authority, signers }, data } = decodeSetTransferFeeInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      authority,
      signers: signers ? signers : null
    },
    data
  };
}
function decodeSetTransferFeeInstructionUnchecked({ programId, keys: [mint, authority, ...signers], data }) {
  const { instruction, transferFeeInstruction, transferFeeBasisPoints, maximumFee } = setTransferFeeInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint,
      authority,
      signers
    },
    data: {
      instruction,
      transferFeeInstruction,
      transferFeeBasisPoints,
      maximumFee
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/actions.js
async function transferCheckedWithFee(connection, payer, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createTransferCheckedWithFeeInstruction(source, mint, destination, ownerPublicKey, amount, decimals, fee, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function withdrawWithheldTokensFromMint(connection, payer, mint, destination, authority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createWithdrawWithheldTokensFromMintInstruction(mint, destination, authorityPublicKey, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function withdrawWithheldTokensFromAccounts(connection, payer, mint, destination, authority, multiSigners, sources, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authorityPublicKey, signers, sources, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function harvestWithheldTokensToMint(connection, payer, mint, sources, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const transaction = new Transaction().add(createHarvestWithheldTokensToMintInstruction(mint, sources, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
}
async function setTransferFee(connection, payer, mint, authority, multiSigners, transferFeeBasisPoints, maximumFee, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createSetTransferFeeInstruction(mint, authorityPublicKey, signers, transferFeeBasisPoints, maximumFee, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferFee/state.js
init_process();
init_buffer();
var import_buffer_layout24 = __toESM(require_Layout(), 1);
var MAX_FEE_BASIS_POINTS = 1e4;
var ONE_IN_BASIS_POINTS = BigInt(MAX_FEE_BASIS_POINTS);
function transferFeeLayout(property) {
  return (0, import_buffer_layout24.struct)([u64("epoch"), u64("maximumFee"), (0, import_buffer_layout24.u16)("transferFeeBasisPoints")], property);
}
function calculateFee(transferFee, preFeeAmount) {
  const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;
  if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {
    return BigInt(0);
  } else {
    const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);
    const rawFee = (numerator + ONE_IN_BASIS_POINTS - BigInt(1)) / ONE_IN_BASIS_POINTS;
    const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;
    return BigInt(fee);
  }
}
var TransferFeeConfigLayout = (0, import_buffer_layout24.struct)([
  publicKey("transferFeeConfigAuthority"),
  publicKey("withdrawWithheldAuthority"),
  u64("withheldAmount"),
  transferFeeLayout("olderTransferFee"),
  transferFeeLayout("newerTransferFee")
]);
var TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;
function getEpochFee(transferFeeConfig, epoch) {
  if (epoch >= transferFeeConfig.newerTransferFee.epoch) {
    return transferFeeConfig.newerTransferFee;
  } else {
    return transferFeeConfig.olderTransferFee;
  }
}
function calculateEpochFee(transferFeeConfig, epoch, preFeeAmount) {
  const transferFee = getEpochFee(transferFeeConfig, epoch);
  return calculateFee(transferFee, preFeeAmount);
}
var TransferFeeAmountLayout = (0, import_buffer_layout24.struct)([u64("withheldAmount")]);
var TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;
function getTransferFeeConfig(mint) {
  const extensionData = getExtensionData(ExtensionType.TransferFeeConfig, mint.tlvData);
  if (extensionData !== null) {
    return TransferFeeConfigLayout.decode(extensionData);
  } else {
    return null;
  }
}
function getTransferFeeAmount(account) {
  const extensionData = getExtensionData(ExtensionType.TransferFeeAmount, account.tlvData);
  if (extensionData !== null) {
    return TransferFeeAmountLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/instructions.js
init_process();
init_buffer();
var import_buffer_layout27 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.js
init_process();
init_buffer();
var import_buffer_layout25 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var transferCheckedInstructionData = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout25.u8)("decimals")
]);
function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferCheckedInstructionData.span);
  transferCheckedInstructionData.encode({
    instruction: TokenInstruction.TransferChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeTransferCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== transferCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.TransferChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!source || !mint || !destination || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      source,
      mint,
      destination,
      owner,
      multiSigners
    },
    data
  };
}
function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      source,
      mint,
      destination,
      owner,
      multiSigners
    },
    data: transferCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/state.js
init_process();
init_buffer();
var import_buffer_layout26 = __toESM(require_Layout(), 1);
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/seeds.js
init_process();
init_buffer();
var DISCRIMINATOR_SPAN = 1;
var LITERAL_LENGTH_SPAN = 1;
var INSTRUCTION_ARG_OFFSET_SPAN = 1;
var INSTRUCTION_ARG_LENGTH_SPAN = 1;
var ACCOUNT_KEY_INDEX_SPAN = 1;
var ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;
var ACCOUNT_DATA_OFFSET_SPAN = 1;
var ACCOUNT_DATA_LENGTH_SPAN = 1;
function unpackSeedLiteral(seeds) {
  if (seeds.length < 1) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [length, ...rest] = seeds;
  if (rest.length < length) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: Buffer.from(rest.slice(0, length)),
    packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length
  };
}
function unpackSeedInstructionArg(seeds, instructionData) {
  if (seeds.length < 2) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [index, length] = seeds;
  if (instructionData.length < length + index) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: instructionData.subarray(index, index + length),
    packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN
  };
}
function unpackSeedAccountKey(seeds, previousMetas) {
  if (seeds.length < 1) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [index] = seeds;
  if (previousMetas.length <= index) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: previousMetas[index].pubkey.toBuffer(),
    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN
  };
}
async function unpackSeedAccountData(seeds, previousMetas, connection) {
  if (seeds.length < 3) {
    throw new TokenTransferHookInvalidSeed();
  }
  const [accountIndex, dataIndex, length] = seeds;
  if (previousMetas.length <= accountIndex) {
    throw new TokenTransferHookInvalidSeed();
  }
  const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);
  if (accountInfo == null) {
    throw new TokenTransferHookAccountDataNotFound();
  }
  if (accountInfo.data.length < dataIndex + length) {
    throw new TokenTransferHookInvalidSeed();
  }
  return {
    data: accountInfo.data.subarray(dataIndex, dataIndex + length),
    packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN
  };
}
async function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {
  const [discriminator, ...rest] = seeds;
  const remaining = new Uint8Array(rest);
  switch (discriminator) {
    case 0:
      return null;
    case 1:
      return unpackSeedLiteral(remaining);
    case 2:
      return unpackSeedInstructionArg(remaining, instructionData);
    case 3:
      return unpackSeedAccountKey(remaining, previousMetas);
    case 4:
      return unpackSeedAccountData(remaining, previousMetas, connection);
    default:
      throw new TokenTransferHookInvalidSeed();
  }
}
async function unpackSeeds(seeds, previousMetas, instructionData, connection) {
  const unpackedSeeds = [];
  let i = 0;
  while (i < 32) {
    const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);
    if (seed == null) {
      break;
    }
    unpackedSeeds.push(seed.data);
    i += seed.packedLength;
  }
  return unpackedSeeds;
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/pubkeyData.js
init_process();
init_buffer();
init_index_browser_esm();
async function unpackPubkeyData(keyDataConfig, previousMetas, instructionData, connection) {
  const [discriminator, ...rest] = keyDataConfig;
  const remaining = new Uint8Array(rest);
  switch (discriminator) {
    case 1:
      return unpackPubkeyDataFromInstructionData(remaining, instructionData);
    case 2:
      return unpackPubkeyDataFromAccountData(remaining, previousMetas, connection);
    default:
      throw new TokenTransferHookInvalidPubkeyData();
  }
}
function unpackPubkeyDataFromInstructionData(remaining, instructionData) {
  if (remaining.length < 1) {
    throw new TokenTransferHookInvalidPubkeyData();
  }
  const dataIndex = remaining[0];
  if (instructionData.length < dataIndex + PUBLIC_KEY_LENGTH) {
    throw new TokenTransferHookPubkeyDataTooSmall();
  }
  return new PublicKey(instructionData.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));
}
async function unpackPubkeyDataFromAccountData(remaining, previousMetas, connection) {
  if (remaining.length < 2) {
    throw new TokenTransferHookInvalidPubkeyData();
  }
  const [accountIndex, dataIndex] = remaining;
  if (previousMetas.length <= accountIndex) {
    throw new TokenTransferHookAccountDataNotFound();
  }
  const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);
  if (accountInfo == null) {
    throw new TokenTransferHookAccountNotFound();
  }
  if (accountInfo.data.length < dataIndex + PUBLIC_KEY_LENGTH) {
    throw new TokenTransferHookPubkeyDataTooSmall();
  }
  return new PublicKey(accountInfo.data.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/state.js
var TransferHookLayout = (0, import_buffer_layout26.struct)([publicKey("authority"), publicKey("programId")]);
var TRANSFER_HOOK_SIZE = TransferHookLayout.span;
function getTransferHook(mint) {
  const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);
  if (extensionData !== null) {
    return TransferHookLayout.decode(extensionData);
  } else {
    return null;
  }
}
var TransferHookAccountLayout = (0, import_buffer_layout26.struct)([bool("transferring")]);
var TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;
function getTransferHookAccount(account) {
  const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);
  if (extensionData !== null) {
    return TransferHookAccountLayout.decode(extensionData);
  } else {
    return null;
  }
}
function getExtraAccountMetaAddress(mint, programId) {
  const seeds = [Buffer.from("extra-account-metas"), mint.toBuffer()];
  return PublicKey.findProgramAddressSync(seeds, programId)[0];
}
var ExtraAccountMetaLayout = (0, import_buffer_layout26.struct)([
  (0, import_buffer_layout26.u8)("discriminator"),
  (0, import_buffer_layout26.blob)(32, "addressConfig"),
  bool("isSigner"),
  bool("isWritable")
]);
var ExtraAccountMetaListLayout = (0, import_buffer_layout26.struct)([
  (0, import_buffer_layout26.u32)("count"),
  (0, import_buffer_layout26.seq)(ExtraAccountMetaLayout, (0, import_buffer_layout26.greedy)(ExtraAccountMetaLayout.span), "extraAccounts")
]);
var ExtraAccountMetaAccountDataLayout = (0, import_buffer_layout26.struct)([
  u64("instructionDiscriminator"),
  (0, import_buffer_layout26.u32)("length"),
  ExtraAccountMetaListLayout.replicate("extraAccountsList")
]);
function getExtraAccountMetas(account) {
  const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;
  return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);
}
async function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {
  if (extraMeta.discriminator === 0) {
    return {
      pubkey: new PublicKey(extraMeta.addressConfig),
      isSigner: extraMeta.isSigner,
      isWritable: extraMeta.isWritable
    };
  } else if (extraMeta.discriminator === 2) {
    const pubkey2 = await unpackPubkeyData(extraMeta.addressConfig, previousMetas, instructionData, connection);
    return {
      pubkey: pubkey2,
      isSigner: extraMeta.isSigner,
      isWritable: extraMeta.isWritable
    };
  }
  let programId = PublicKey.default;
  if (extraMeta.discriminator === 1) {
    programId = transferHookProgramId;
  } else {
    const accountIndex = extraMeta.discriminator - (1 << 7);
    if (previousMetas.length <= accountIndex) {
      throw new TokenTransferHookAccountNotFound();
    }
    programId = previousMetas[accountIndex].pubkey;
  }
  const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);
  const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];
  return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/instructions.js
var TransferHookInstruction;
(function(TransferHookInstruction2) {
  TransferHookInstruction2[TransferHookInstruction2["Initialize"] = 0] = "Initialize";
  TransferHookInstruction2[TransferHookInstruction2["Update"] = 1] = "Update";
})(TransferHookInstruction || (TransferHookInstruction = {}));
var initializeTransferHookInstructionData = (0, import_buffer_layout27.struct)([
  (0, import_buffer_layout27.u8)("instruction"),
  (0, import_buffer_layout27.u8)("transferHookInstruction"),
  publicKey("authority"),
  publicKey("transferHookProgramId")
]);
function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeTransferHookInstructionData.span);
  initializeTransferHookInstructionData.encode({
    instruction: TokenInstruction.TransferHookExtension,
    transferHookInstruction: TransferHookInstruction.Initialize,
    authority,
    transferHookProgramId
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var updateTransferHookInstructionData = (0, import_buffer_layout27.struct)([
  (0, import_buffer_layout27.u8)("instruction"),
  (0, import_buffer_layout27.u8)("transferHookInstruction"),
  publicKey("transferHookProgramId")
]);
function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(updateTransferHookInstructionData.span);
  updateTransferHookInstructionData.encode({
    instruction: TokenInstruction.TransferHookExtension,
    transferHookInstruction: TransferHookInstruction.Update,
    transferHookProgramId
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function deEscalateAccountMeta(accountMeta, accountMetas) {
  const maybeHighestPrivileges = accountMetas.filter((x) => x.pubkey.equals(accountMeta.pubkey)).reduce((acc, x) => {
    if (!acc)
      return { isSigner: x.isSigner, isWritable: x.isWritable };
    return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };
  }, void 0);
  if (maybeHighestPrivileges) {
    const { isSigner, isWritable } = maybeHighestPrivileges;
    if (!isSigner && isSigner !== accountMeta.isSigner) {
      accountMeta.isSigner = false;
    }
    if (!isWritable && isWritable !== accountMeta.isWritable) {
      accountMeta.isWritable = false;
    }
  }
  return accountMeta;
}
function createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, amount) {
  const keys = [source, mint, destination, owner, validateStatePubkey].map((pubkey) => ({
    pubkey,
    isSigner: false,
    isWritable: false
  }));
  const data = Buffer.alloc(16);
  data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0);
  data.writeBigUInt64LE(BigInt(amount), 8);
  return new TransactionInstruction({ keys, programId, data });
}
async function addExtraAccountMetasForExecute(connection, instruction, programId, source, mint, destination, owner, amount, commitment) {
  const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);
  const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);
  if (validateStateAccount == null) {
    return instruction;
  }
  const validateStateData = getExtraAccountMetas(validateStateAccount);
  if (![source, mint, destination, owner].every((key) => instruction.keys.some((meta) => meta.pubkey.equals(key)))) {
    throw new Error("Missing required account in instruction");
  }
  const executeInstruction = createExecuteInstruction(programId, source, mint, destination, owner, validateStatePubkey, BigInt(amount));
  for (const extraAccountMeta of validateStateData) {
    executeInstruction.keys.push(deEscalateAccountMeta(await resolveExtraAccountMeta(connection, extraAccountMeta, executeInstruction.keys, executeInstruction.data, executeInstruction.programId), executeInstruction.keys));
  }
  instruction.keys.push(...executeInstruction.keys.slice(5));
  instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });
  instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });
}
async function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, owner, amount, decimals, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {
  const instruction = createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners, programId);
  const mintInfo = await getMint(connection, mint, commitment, programId);
  const transferHook = getTransferHook(mintInfo);
  if (transferHook) {
    await addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);
  }
  return instruction;
}
async function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {
  const instruction = createTransferCheckedWithFeeInstruction(source, mint, destination, owner, amount, decimals, fee, multiSigners, programId);
  const mintInfo = await getMint(connection, mint, commitment, programId);
  const transferHook = getTransferHook(mintInfo);
  if (transferHook) {
    await addExtraAccountMetasForExecute(connection, instruction, transferHook.programId, source, mint, destination, owner, amount, commitment);
  }
  return instruction;
}

// node_modules/@solana/spl-token/lib/esm/extensions/transferHook/actions.js
async function initializeTransferHook(connection, payer, mint, authority, transferHookProgramId, confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const transaction = new Transaction().add(createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
}
async function updateTransferHook(connection, payer, mint, transferHookProgramId, authority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createUpdateTransferHookInstruction(mint, authorityPublicKey, transferHookProgramId, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function transferCheckedWithTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(await createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authorityPublicKey, amount, decimals, signers, confirmOptions == null ? void 0 : confirmOptions.commitment, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function transferCheckedWithFeeAndTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(await createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authorityPublicKey, amount, decimals, fee, signers, confirmOptions == null ? void 0 : confirmOptions.commitment, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/extensionType.js
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
  ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
  ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
  ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
  ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
  ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
  ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
  ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
  ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
  ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
  ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
  ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
  ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
  ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
  ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
  ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
  ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
  ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
  ExtensionType2[ExtensionType2["GroupPointer"] = 20] = "GroupPointer";
  ExtensionType2[ExtensionType2["TokenGroup"] = 21] = "TokenGroup";
  ExtensionType2[ExtensionType2["GroupMemberPointer"] = 22] = "GroupMemberPointer";
  ExtensionType2[ExtensionType2["TokenGroupMember"] = 23] = "TokenGroupMember";
  ExtensionType2[ExtensionType2["ScaledUiAmountConfig"] = 25] = "ScaledUiAmountConfig";
  ExtensionType2[ExtensionType2["PausableConfig"] = 26] = "PausableConfig";
  ExtensionType2[ExtensionType2["PausableAccount"] = 27] = "PausableAccount";
})(ExtensionType || (ExtensionType = {}));
var TYPE_SIZE = 2;
var LENGTH_SIZE = 2;
function addTypeAndLengthToLen(len) {
  return len + TYPE_SIZE + LENGTH_SIZE;
}
function isVariableLengthExtension(e) {
  switch (e) {
    case ExtensionType.TokenMetadata:
      return true;
    default:
      return false;
  }
}
function getTypeLen(e) {
  switch (e) {
    case ExtensionType.Uninitialized:
      return 0;
    case ExtensionType.TransferFeeConfig:
      return TRANSFER_FEE_CONFIG_SIZE;
    case ExtensionType.TransferFeeAmount:
      return TRANSFER_FEE_AMOUNT_SIZE;
    case ExtensionType.MintCloseAuthority:
      return MINT_CLOSE_AUTHORITY_SIZE;
    case ExtensionType.ConfidentialTransferMint:
      return 65;
    case ExtensionType.ConfidentialTransferAccount:
      return 295;
    case ExtensionType.CpiGuard:
      return CPI_GUARD_SIZE;
    case ExtensionType.DefaultAccountState:
      return DEFAULT_ACCOUNT_STATE_SIZE;
    case ExtensionType.ImmutableOwner:
      return IMMUTABLE_OWNER_SIZE;
    case ExtensionType.MemoTransfer:
      return MEMO_TRANSFER_SIZE;
    case ExtensionType.MetadataPointer:
      return METADATA_POINTER_SIZE;
    case ExtensionType.NonTransferable:
      return NON_TRANSFERABLE_SIZE;
    case ExtensionType.InterestBearingConfig:
      return INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
    case ExtensionType.PermanentDelegate:
      return PERMANENT_DELEGATE_SIZE;
    case ExtensionType.NonTransferableAccount:
      return NON_TRANSFERABLE_ACCOUNT_SIZE;
    case ExtensionType.TransferHook:
      return TRANSFER_HOOK_SIZE;
    case ExtensionType.TransferHookAccount:
      return TRANSFER_HOOK_ACCOUNT_SIZE;
    case ExtensionType.GroupPointer:
      return GROUP_POINTER_SIZE;
    case ExtensionType.GroupMemberPointer:
      return GROUP_MEMBER_POINTER_SIZE;
    case ExtensionType.TokenGroup:
      return TOKEN_GROUP_SIZE;
    case ExtensionType.TokenGroupMember:
      return TOKEN_GROUP_MEMBER_SIZE;
    case ExtensionType.ScaledUiAmountConfig:
      return SCALED_UI_AMOUNT_CONFIG_SIZE;
    case ExtensionType.PausableConfig:
      return PAUSABLE_CONFIG_SIZE;
    case ExtensionType.PausableAccount:
      return PAUSABLE_ACCOUNT_SIZE;
    case ExtensionType.TokenMetadata:
      throw Error(`Cannot get type length for variable extension type: ${e}`);
    default:
      throw Error(`Unknown extension type: ${e}`);
  }
}
function isMintExtension(e) {
  switch (e) {
    case ExtensionType.TransferFeeConfig:
    case ExtensionType.MintCloseAuthority:
    case ExtensionType.ConfidentialTransferMint:
    case ExtensionType.DefaultAccountState:
    case ExtensionType.NonTransferable:
    case ExtensionType.InterestBearingConfig:
    case ExtensionType.PermanentDelegate:
    case ExtensionType.TransferHook:
    case ExtensionType.MetadataPointer:
    case ExtensionType.TokenMetadata:
    case ExtensionType.GroupPointer:
    case ExtensionType.GroupMemberPointer:
    case ExtensionType.TokenGroup:
    case ExtensionType.TokenGroupMember:
    case ExtensionType.ScaledUiAmountConfig:
    case ExtensionType.PausableConfig:
      return true;
    case ExtensionType.Uninitialized:
    case ExtensionType.TransferFeeAmount:
    case ExtensionType.ConfidentialTransferAccount:
    case ExtensionType.ImmutableOwner:
    case ExtensionType.MemoTransfer:
    case ExtensionType.CpiGuard:
    case ExtensionType.NonTransferableAccount:
    case ExtensionType.TransferHookAccount:
    case ExtensionType.PausableAccount:
      return false;
    default:
      throw Error(`Unknown extension type: ${e}`);
  }
}
function isAccountExtension(e) {
  switch (e) {
    case ExtensionType.TransferFeeAmount:
    case ExtensionType.ConfidentialTransferAccount:
    case ExtensionType.ImmutableOwner:
    case ExtensionType.MemoTransfer:
    case ExtensionType.CpiGuard:
    case ExtensionType.NonTransferableAccount:
    case ExtensionType.TransferHookAccount:
    case ExtensionType.PausableAccount:
      return true;
    case ExtensionType.Uninitialized:
    case ExtensionType.TransferFeeConfig:
    case ExtensionType.MintCloseAuthority:
    case ExtensionType.ConfidentialTransferMint:
    case ExtensionType.DefaultAccountState:
    case ExtensionType.NonTransferable:
    case ExtensionType.InterestBearingConfig:
    case ExtensionType.PermanentDelegate:
    case ExtensionType.TransferHook:
    case ExtensionType.MetadataPointer:
    case ExtensionType.TokenMetadata:
    case ExtensionType.GroupPointer:
    case ExtensionType.GroupMemberPointer:
    case ExtensionType.TokenGroup:
    case ExtensionType.TokenGroupMember:
    case ExtensionType.ScaledUiAmountConfig:
    case ExtensionType.PausableConfig:
      return false;
    default:
      throw Error(`Unknown extension type: ${e}`);
  }
}
function getAccountTypeOfMintType(e) {
  switch (e) {
    case ExtensionType.TransferFeeConfig:
      return ExtensionType.TransferFeeAmount;
    case ExtensionType.ConfidentialTransferMint:
      return ExtensionType.ConfidentialTransferAccount;
    case ExtensionType.NonTransferable:
      return ExtensionType.NonTransferableAccount;
    case ExtensionType.TransferHook:
      return ExtensionType.TransferHookAccount;
    case ExtensionType.PausableConfig:
      return ExtensionType.PausableAccount;
    case ExtensionType.TransferFeeAmount:
    case ExtensionType.ConfidentialTransferAccount:
    case ExtensionType.CpiGuard:
    case ExtensionType.DefaultAccountState:
    case ExtensionType.ImmutableOwner:
    case ExtensionType.MemoTransfer:
    case ExtensionType.MintCloseAuthority:
    case ExtensionType.MetadataPointer:
    case ExtensionType.TokenMetadata:
    case ExtensionType.Uninitialized:
    case ExtensionType.InterestBearingConfig:
    case ExtensionType.PermanentDelegate:
    case ExtensionType.NonTransferableAccount:
    case ExtensionType.TransferHookAccount:
    case ExtensionType.GroupPointer:
    case ExtensionType.GroupMemberPointer:
    case ExtensionType.TokenGroup:
    case ExtensionType.TokenGroupMember:
    case ExtensionType.ScaledUiAmountConfig:
    case ExtensionType.PausableAccount:
      return ExtensionType.Uninitialized;
  }
}
function getLen(extensionTypes, baseSize, variableLengthExtensions = {}) {
  if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {
    return baseSize;
  } else {
    const accountLength = ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE + extensionTypes.filter((element, i) => i === extensionTypes.indexOf(element)).map((element) => addTypeAndLengthToLen(getTypeLen(element))).reduce((a, b) => a + b, 0) + Object.entries(variableLengthExtensions).map(([extension, len]) => {
      if (!isVariableLengthExtension(Number(extension))) {
        throw Error(`Extension ${extension} is not variable length`);
      }
      return addTypeAndLengthToLen(len);
    }).reduce((a, b) => a + b, 0);
    if (accountLength === MULTISIG_SIZE) {
      return accountLength + TYPE_SIZE;
    } else {
      return accountLength;
    }
  }
}
function getMintLen(extensionTypes, variableLengthExtensions = {}) {
  return getLen(extensionTypes, MINT_SIZE, variableLengthExtensions);
}
function getAccountLen(extensionTypes) {
  return getLen(extensionTypes, ACCOUNT_SIZE);
}
function getExtensionData(extension, tlvData) {
  let extensionTypeIndex = 0;
  while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {
    const entryType = tlvData.readUInt16LE(extensionTypeIndex);
    const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);
    const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);
    if (entryType == extension) {
      return tlvData.slice(typeIndex, typeIndex + entryLength);
    }
    extensionTypeIndex = typeIndex + entryLength;
  }
  return null;
}
function getExtensionTypes(tlvData) {
  const extensionTypes = [];
  let extensionTypeIndex = 0;
  while (extensionTypeIndex < tlvData.length) {
    const entryType = tlvData.readUInt16LE(extensionTypeIndex);
    extensionTypes.push(entryType);
    const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);
    extensionTypeIndex += addTypeAndLengthToLen(entryLength);
  }
  return extensionTypes;
}
function getAccountLenForMint(mint) {
  const extensionTypes = getExtensionTypes(mint.tlvData);
  const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);
  return getAccountLen(accountExtensions);
}
function getNewAccountLenForExtensionLen(info, address, extensionType, extensionLen, programId = TOKEN_2022_PROGRAM_ID) {
  const mint = unpackMint(address, info, programId);
  const extensionData = getExtensionData(extensionType, mint.tlvData);
  const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;
  const newExtensionLen = addTypeAndLengthToLen(extensionLen);
  return info.data.length + newExtensionLen - currentExtensionLen;
}

// node_modules/@solana/spl-token/lib/esm/state/mint.js
var MintLayout = (0, import_buffer_layout28.struct)([
  (0, import_buffer_layout28.u32)("mintAuthorityOption"),
  publicKey("mintAuthority"),
  u64("supply"),
  (0, import_buffer_layout28.u8)("decimals"),
  bool("isInitialized"),
  (0, import_buffer_layout28.u32)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address, commitment);
  return unpackMint(address, info, programId);
}
function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < MINT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > MINT_SIZE) {
    if (info.data.length <= ACCOUNT_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Mint)
      throw new TokenInvalidMintError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
    supply: rawMint.supply,
    decimals: rawMint.decimals,
    isInitialized: rawMint.isInitialized,
    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
    tlvData
  };
}
async function getMinimumBalanceForRentExemptMint(connection, commitment) {
  return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);
}
async function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {
  const mintLen = getMintLen(extensions);
  return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);
}
async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}
function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
  return address;
}

// node_modules/@solana/spl-token/lib/esm/actions/amountToUiAmount.js
async function amountToUiAmount(connection, payer, mint, amount, programId = TOKEN_PROGRAM_ID) {
  const transaction = new Transaction().add(createAmountToUiAmountInstruction(mint, amount, programId));
  const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;
  if (returnData == null ? void 0 : returnData.data) {
    return Buffer.from(returnData.data[0], returnData.data[1]).toString("utf-8");
  }
  return err;
}
function calculateExponentForTimesAndRate(t1, t2, r) {
  const ONE_IN_BASIS_POINTS2 = 1e4;
  const SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;
  const timespan = t2 - t1;
  const numerator = r * timespan;
  const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS2);
  return Math.exp(exponent);
}
async function getSysvarClockTimestamp(connection) {
  const info = await connection.getParsedAccountInfo(new PublicKey("SysvarC1ock11111111111111111111111111111111"));
  if (!info) {
    throw new Error("Failed to fetch sysvar clock");
  }
  if (typeof info.value === "object" && info.value && "data" in info.value && "parsed" in info.value.data) {
    return info.value.data.parsed.info.unixTimestamp;
  }
  throw new Error("Failed to parse sysvar clock");
}
function amountToUiAmountWithoutSimulation(amount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {
  const preUpdateExp = calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);
  const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);
  const totalScale = preUpdateExp * postUpdateExp;
  const scaledAmount = Number(amount) * totalScale;
  const decimalFactor = Math.pow(10, decimals);
  return (Math.trunc(scaledAmount) / decimalFactor).toString();
}
async function amountToUiAmountForMintWithoutSimulation(connection, mint, amount) {
  const accountInfo = await connection.getAccountInfo(mint);
  const programId = accountInfo == null ? void 0 : accountInfo.owner;
  if (programId !== TOKEN_PROGRAM_ID && programId !== TOKEN_2022_PROGRAM_ID) {
    throw new Error("Invalid program ID");
  }
  const mintInfo = unpackMint(mint, accountInfo, programId);
  const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);
  if (!interestBearingMintConfigState) {
    const amountNumber = Number(amount);
    const decimalsFactor = Math.pow(10, mintInfo.decimals);
    return (amountNumber / decimalsFactor).toString();
  }
  const timestamp = await getSysvarClockTimestamp(connection);
  return amountToUiAmountWithoutSimulation(amount, mintInfo.decimals, timestamp, Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);
}
function uiAmountToAmountWithoutSimulation(uiAmount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {
  const uiAmountNumber = parseFloat(uiAmount);
  const decimalsFactor = Math.pow(10, decimals);
  const uiAmountScaled = uiAmountNumber * decimalsFactor;
  const preUpdateExp = calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);
  const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);
  const totalScale = preUpdateExp * postUpdateExp;
  const originalPrincipal = uiAmountScaled / totalScale;
  return BigInt(Math.trunc(originalPrincipal));
}
async function uiAmountToAmountForMintWithoutSimulation(connection, mint, uiAmount) {
  const accountInfo = await connection.getAccountInfo(mint);
  const programId = accountInfo == null ? void 0 : accountInfo.owner;
  if (programId !== TOKEN_PROGRAM_ID && programId !== TOKEN_2022_PROGRAM_ID) {
    throw new Error("Invalid program ID");
  }
  const mintInfo = unpackMint(mint, accountInfo, programId);
  const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);
  if (!interestBearingMintConfigState) {
    const uiAmountScaled = parseFloat(uiAmount) * Math.pow(10, mintInfo.decimals);
    return BigInt(Math.trunc(uiAmountScaled));
  }
  const timestamp = await getSysvarClockTimestamp(connection);
  return uiAmountToAmountWithoutSimulation(uiAmount, mintInfo.decimals, timestamp, Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);
}

// node_modules/@solana/spl-token/lib/esm/actions/approve.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/approve.js
init_process();
init_buffer();
var import_buffer_layout29 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var approveInstructionData = (0, import_buffer_layout29.struct)([(0, import_buffer_layout29.u8)("instruction"), u64("amount")]);
function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: delegate, isSigner: false, isWritable: false }
  ], owner, multiSigners);
  const data = Buffer.alloc(approveInstructionData.span);
  approveInstructionData.encode({
    instruction: TokenInstruction.Approve,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeApproveInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== approveInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Approve)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !delegate || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      delegate,
      owner,
      multiSigners
    },
    data
  };
}
function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      delegate,
      owner,
      multiSigners
    },
    data: approveInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/approve.js
async function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/approveChecked.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/approveChecked.js
init_process();
init_buffer();
var import_buffer_layout30 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var approveCheckedInstructionData = (0, import_buffer_layout30.struct)([
  (0, import_buffer_layout30.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout30.u8)("decimals")
]);
function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: delegate, isSigner: false, isWritable: false }
  ], owner, multiSigners);
  const data = Buffer.alloc(approveCheckedInstructionData.span);
  approveCheckedInstructionData.encode({
    instruction: TokenInstruction.ApproveChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeApproveCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== approveCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.ApproveChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !delegate || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      delegate,
      owner,
      multiSigners
    },
    data
  };
}
function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      delegate,
      owner,
      multiSigners
    },
    data: approveCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/approveChecked.js
async function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createApproveCheckedInstruction(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/burn.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/burn.js
init_process();
init_buffer();
var import_buffer_layout31 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var burnInstructionData = (0, import_buffer_layout31.struct)([(0, import_buffer_layout31.u8)("instruction"), u64("amount")]);
function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(burnInstructionData.span);
  burnInstructionData.encode({
    instruction: TokenInstruction.Burn,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeBurnInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== burnInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Burn)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data
  };
}
function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data: burnInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/burn.js
async function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/burnChecked.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/burnChecked.js
init_process();
init_buffer();
var import_buffer_layout32 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var burnCheckedInstructionData = (0, import_buffer_layout32.struct)([
  (0, import_buffer_layout32.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout32.u8)("decimals")
]);
function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(burnCheckedInstructionData.span);
  burnCheckedInstructionData.encode({
    instruction: TokenInstruction.BurnChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeBurnCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== burnCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.BurnChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data
  };
}
function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      multiSigners
    },
    data: burnCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/burnChecked.js
async function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/closeAccount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/closeAccount.js
init_process();
init_buffer();
var import_buffer_layout33 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var closeAccountInstructionData = (0, import_buffer_layout33.struct)([(0, import_buffer_layout33.u8)("instruction")]);
function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(closeAccountInstructionData.span);
  closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeCloseAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== closeAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.CloseAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !destination || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      destination,
      authority,
      multiSigners
    },
    data
  };
}
function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      destination,
      authority,
      multiSigners
    },
    data: closeAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/closeAccount.js
async function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/createAccount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount.js
init_process();
init_buffer();
var import_buffer_layout34 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeAccountInstructionData = (0, import_buffer_layout34.struct)([(0, import_buffer_layout34.u8)("instruction")]);
function createInitializeAccountInstruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeAccountInstructionData.span);
  initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !owner || !rent)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      rent
    },
    data
  };
}
function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      owner,
      rent
    },
    data: initializeAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/associatedTokenAccount.js
init_process();
init_buffer();
init_index_browser_esm();
function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);
}
function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
}
function createAssociatedTokenAccountIdempotentInstructionWithDerivation(payer, owner, mint, allowOwnerOffCurve = true, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve);
  return createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId, associatedTokenProgramId);
}
function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: instructionData
  });
}
function createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, ownerMint, owner, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },
    { pubkey: nestedMint, isSigner: false, isWritable: false },
    { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },
    { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },
    { pubkey: ownerMint, isSigner: false, isWritable: false },
    { pubkey: owner, isSigner: true, isWritable: true },
    { pubkey: programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: Buffer.from([2])
  });
}

// node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccount.js
async function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID, allowOwnerOffCurve = false) {
  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
  const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
  await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
  return associatedToken;
}

// node_modules/@solana/spl-token/lib/esm/actions/createAccount.js
async function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = TOKEN_PROGRAM_ID) {
  if (!keypair)
    return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);
  const mintState = await getMint(connection, mint, confirmOptions == null ? void 0 : confirmOptions.commitment, programId);
  const space = getAccountLenForMint(mintState);
  const lamports = await connection.getMinimumBalanceForRentExemption(space);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space,
    lamports,
    programId
  }), createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccountIdempotent.js
init_process();
init_buffer();
init_index_browser_esm();
async function createAssociatedTokenAccountIdempotent(connection, payer, mint, owner, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID, allowOwnerOffCurve = false) {
  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
  const transaction = new Transaction().add(createAssociatedTokenAccountIdempotentInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
  await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
  return associatedToken;
}

// node_modules/@solana/spl-token/lib/esm/actions/createMint.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMint2.js
init_process();
init_buffer();
var import_buffer_layout35 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMint2InstructionData = (0, import_buffer_layout35.struct)([
  (0, import_buffer_layout35.u8)("instruction"),
  (0, import_buffer_layout35.u8)("decimals"),
  publicKey("mintAuthority"),
  new COptionPublicKeyLayout("freezeAuthority")
]);
function createInitializeMint2Instruction(mint, decimals, mintAuthority, freezeAuthority, programId = TOKEN_PROGRAM_ID) {
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(67);
  initializeMint2InstructionData.encode({
    instruction: TokenInstruction.InitializeMint2,
    decimals,
    mintAuthority,
    freezeAuthority
  }, data);
  return new TransactionInstruction({
    keys,
    programId,
    data: data.subarray(0, initializeMint2InstructionData.getSpan(data))
  });
}
function decodeInitializeMint2Instruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeMint2InstructionData.getSpan(instruction.data))
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint }, data } = decodeInitializeMint2InstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeMint2)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint
    },
    data
  };
}
function decodeInitializeMint2InstructionUnchecked({ programId, keys: [mint], data }) {
  const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMint2InstructionData.decode(data);
  return {
    programId,
    keys: {
      mint
    },
    data: {
      instruction,
      decimals,
      mintAuthority,
      freezeAuthority
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/createMint.js
async function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const lamports = await getMinimumBalanceForRentExemptMint(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: MINT_SIZE,
    lamports,
    programId
  }), createInitializeMint2Instruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/createMultisig.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMultisig.js
init_process();
init_buffer();
var import_buffer_layout36 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMultisigInstructionData = (0, import_buffer_layout36.struct)([
  (0, import_buffer_layout36.u8)("instruction"),
  (0, import_buffer_layout36.u8)("m")
]);
function createInitializeMultisigInstruction(account, signers, m, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  for (const signer of signers) {
    keys.push({
      pubkey: signer instanceof PublicKey ? signer : signer.publicKey,
      isSigner: false,
      isWritable: false
    });
  }
  const data = Buffer.alloc(initializeMultisigInstructionData.span);
  initializeMultisigInstructionData.encode({
    instruction: TokenInstruction.InitializeMultisig,
    m
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeMultisigInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeMultisigInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeMultisig)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !rent || !signers.length)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      rent,
      signers
    },
    data
  };
}
function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
  return {
    programId,
    keys: {
      account,
      rent,
      signers
    },
    data: initializeMultisigInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/createMultisig.js
async function createMultisig(connection, payer, signers, m, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const lamports = await getMinimumBalanceForRentExemptMultisig(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: MULTISIG_SIZE,
    lamports,
    programId
  }), createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/createNativeMint.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/createNativeMint.js
init_process();
init_buffer();
var import_buffer_layout37 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var createNativeMintInstructionData = (0, import_buffer_layout37.struct)([(0, import_buffer_layout37.u8)("instruction")]);
function createCreateNativeMintInstruction(payer, nativeMintId = NATIVE_MINT_2022, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: nativeMintId, isSigner: false, isWritable: true },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(createNativeMintInstructionData.span);
  createNativeMintInstructionData.encode({ instruction: TokenInstruction.CreateNativeMint }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/actions/createNativeMint.js
async function createNativeMint(connection, payer, confirmOptions, nativeMint = NATIVE_MINT_2022, programId = TOKEN_2022_PROGRAM_ID) {
  const transaction = new Transaction().add(createCreateNativeMintInstruction(payer.publicKey, nativeMint, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/createWrappedNativeAccount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/syncNative.js
init_process();
init_buffer();
var import_buffer_layout38 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var syncNativeInstructionData = (0, import_buffer_layout38.struct)([(0, import_buffer_layout38.u8)("instruction")]);
function createSyncNativeInstruction(account, programId = TOKEN_PROGRAM_ID) {
  const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(syncNativeInstructionData.span);
  syncNativeInstructionData.encode({ instruction: TokenInstruction.SyncNative }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeSyncNativeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== syncNativeInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.SyncNative)
    throw new TokenInvalidInstructionTypeError();
  if (!account)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account
    },
    data
  };
}
function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
  return {
    programId,
    keys: {
      account
    },
    data: syncNativeInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/createWrappedNativeAccount.js
async function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = TOKEN_PROGRAM_ID, nativeMint = NATIVE_MINT) {
  if (!amount)
    return await createAccount(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);
  if (!keypair) {
    const associatedToken = getAssociatedTokenAddressSync(nativeMint, owner, false, programId, ASSOCIATED_TOKEN_PROGRAM_ID);
    const transaction2 = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, nativeMint, programId, ASSOCIATED_TOKEN_PROGRAM_ID), SystemProgram.transfer({
      fromPubkey: payer.publicKey,
      toPubkey: associatedToken,
      lamports: amount
    }), createSyncNativeInstruction(associatedToken, programId));
    await sendAndConfirmTransaction(connection, transaction2, [payer], confirmOptions);
    return associatedToken;
  }
  const lamports = await getMinimumBalanceForRentExemptAccount(connection);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: ACCOUNT_SIZE,
    lamports,
    programId
  }), SystemProgram.transfer({
    fromPubkey: payer.publicKey,
    toPubkey: keypair.publicKey,
    lamports: amount
  }), createInitializeAccountInstruction(keypair.publicKey, nativeMint, owner, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}

// node_modules/@solana/spl-token/lib/esm/actions/freezeAccount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/freezeAccount.js
init_process();
init_buffer();
var import_buffer_layout39 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var freezeAccountInstructionData = (0, import_buffer_layout39.struct)([(0, import_buffer_layout39.u8)("instruction")]);
function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false }
  ], authority, multiSigners);
  const data = Buffer.alloc(freezeAccountInstructionData.span);
  freezeAccountInstructionData.encode({ instruction: TokenInstruction.FreezeAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeFreezeAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== freezeAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.FreezeAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data
  };
}
function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data: freezeAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/freezeAccount.js
async function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/getOrCreateAssociatedTokenAccount.js
init_process();
init_buffer();
init_index_browser_esm();
async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
  let account;
  try {
    account = await getAccount(connection, associatedToken, commitment, programId);
  } catch (error) {
    if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {
      try {
        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
      } catch (error2) {
      }
      account = await getAccount(connection, associatedToken, commitment, programId);
    } else {
      throw error;
    }
  }
  if (!account.mint.equals(mint))
    throw new TokenInvalidMintError();
  if (!account.owner.equals(owner))
    throw new TokenInvalidOwnerError();
  return account;
}

// node_modules/@solana/spl-token/lib/esm/actions/mintTo.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/mintTo.js
init_process();
init_buffer();
var import_buffer_layout40 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var mintToInstructionData = (0, import_buffer_layout40.struct)([(0, import_buffer_layout40.u8)("instruction"), u64("amount")]);
function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(mintToInstructionData.span);
  mintToInstructionData.encode({
    instruction: TokenInstruction.MintTo,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeMintToInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== mintToInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.MintTo)
    throw new TokenInvalidInstructionTypeError();
  if (!mint || !destination || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data
  };
}
function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data: mintToInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/mintTo.js
async function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/mintToChecked.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/mintToChecked.js
init_process();
init_buffer();
var import_buffer_layout41 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var mintToCheckedInstructionData = (0, import_buffer_layout41.struct)([
  (0, import_buffer_layout41.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout41.u8)("decimals")
]);
function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(mintToCheckedInstructionData.span);
  mintToCheckedInstructionData.encode({
    instruction: TokenInstruction.MintToChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeMintToCheckedInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== mintToCheckedInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.MintToChecked)
    throw new TokenInvalidInstructionTypeError();
  if (!mint || !destination || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data
  };
}
function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      mint,
      destination,
      authority,
      multiSigners
    },
    data: mintToCheckedInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/mintToChecked.js
async function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createMintToCheckedInstruction(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/recoverNested.js
init_process();
init_buffer();
init_index_browser_esm();
async function recoverNested(connection, payer, owner, mint, nestedMint, confirmOptions, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const ownerAssociatedToken = getAssociatedTokenAddressSync(mint, owner.publicKey, false, programId, associatedTokenProgramId);
  const destinationAssociatedToken = getAssociatedTokenAddressSync(nestedMint, owner.publicKey, false, programId, associatedTokenProgramId);
  const nestedAssociatedToken = getAssociatedTokenAddressSync(nestedMint, ownerAssociatedToken, true, programId, associatedTokenProgramId);
  const transaction = new Transaction().add(createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, mint, owner.publicKey, programId, associatedTokenProgramId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, owner], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/revoke.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/revoke.js
init_process();
init_buffer();
var import_buffer_layout42 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var revokeInstructionData = (0, import_buffer_layout42.struct)([(0, import_buffer_layout42.u8)("instruction")]);
function createRevokeInstruction(account, owner, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);
  const data = Buffer.alloc(revokeInstructionData.span);
  revokeInstructionData.encode({ instruction: TokenInstruction.Revoke }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeRevokeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== revokeInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Revoke)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      owner,
      multiSigners
    },
    data
  };
}
function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      owner,
      multiSigners
    },
    data: revokeInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/revoke.js
async function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createRevokeInstruction(account, ownerPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/setAuthority.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/setAuthority.js
init_process();
init_buffer();
var import_buffer_layout43 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
  AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
  AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
  AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
  AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
  AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
  AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
  AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
  AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
  AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
  AuthorityType2[AuthorityType2["GroupPointer"] = 13] = "GroupPointer";
  AuthorityType2[AuthorityType2["GroupMemberPointer"] = 14] = "GroupMemberPointer";
  AuthorityType2[AuthorityType2["ScaledUiAmountConfig"] = 15] = "ScaledUiAmountConfig";
  AuthorityType2[AuthorityType2["PausableConfig"] = 16] = "PausableConfig";
})(AuthorityType || (AuthorityType = {}));
var setAuthorityInstructionData = (0, import_buffer_layout43.struct)([
  (0, import_buffer_layout43.u8)("instruction"),
  (0, import_buffer_layout43.u8)("authorityType"),
  new COptionPublicKeyLayout("newAuthority")
]);
function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);
  const data = Buffer.alloc(35);
  setAuthorityInstructionData.encode({
    instruction: TokenInstruction.SetAuthority,
    authorityType,
    newAuthority
  }, data);
  return new TransactionInstruction({
    keys,
    programId,
    data: data.subarray(0, setAuthorityInstructionData.getSpan(data))
  });
}
function decodeSetAuthorityInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== setAuthorityInstructionData.getSpan(instruction.data))
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.SetAuthority)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !currentAuthority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      currentAuthority,
      multiSigners
    },
    data
  };
}
function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
  const { instruction, authorityType, newAuthority } = setAuthorityInstructionData.decode(data);
  return {
    programId,
    keys: {
      account,
      currentAuthority,
      multiSigners
    },
    data: {
      instruction,
      authorityType,
      newAuthority
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/setAuthority.js
async function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);
  const transaction = new Transaction().add(createSetAuthorityInstruction(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/syncNative.js
init_process();
init_buffer();
init_index_browser_esm();
async function syncNative(connection, payer, account, confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/thawAccount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/thawAccount.js
init_process();
init_buffer();
var import_buffer_layout44 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var thawAccountInstructionData = (0, import_buffer_layout44.struct)([(0, import_buffer_layout44.u8)("instruction")]);
function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false }
  ], authority, multiSigners);
  const data = Buffer.alloc(thawAccountInstructionData.span);
  thawAccountInstructionData.encode({ instruction: TokenInstruction.ThawAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeThawAccountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== thawAccountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.ThawAccount)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !authority)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data
  };
}
function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      authority,
      multiSigners
    },
    data: thawAccountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/thawAccount.js
async function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [authorityPublicKey, signers] = getSigners(authority, multiSigners);
  const transaction = new Transaction().add(createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/transfer.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/transfer.js
init_process();
init_buffer();
var import_buffer_layout45 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var transferInstructionData = (0, import_buffer_layout45.struct)([(0, import_buffer_layout45.u8)("instruction"), u64("amount")]);
function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferInstructionData.span);
  transferInstructionData.encode({
    instruction: TokenInstruction.Transfer,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeTransferInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== transferInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.Transfer)
    throw new TokenInvalidInstructionTypeError();
  if (!source || !destination || !owner)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      source,
      destination,
      owner,
      multiSigners
    },
    data
  };
}
function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
  return {
    programId,
    keys: {
      source,
      destination,
      owner,
      multiSigners
    },
    data: transferInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/transfer.js
async function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/transferChecked.js
init_process();
init_buffer();
init_index_browser_esm();
async function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = TOKEN_PROGRAM_ID) {
  const [ownerPublicKey, signers] = getSigners(owner, multiSigners);
  const transaction = new Transaction().add(createTransferCheckedInstruction(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/actions/uiAmountToAmount.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/uiAmountToAmount.js
init_process();
init_buffer();
var import_buffer_layout46 = __toESM(require_Layout(), 1);
init_index_browser_esm();
function createUiAmountToAmountInstruction(mint, amount, programId = TOKEN_PROGRAM_ID) {
  const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
  const buf = Buffer.from(amount, "utf8");
  const uiAmountToAmountInstructionData = (0, import_buffer_layout46.struct)([
    (0, import_buffer_layout46.u8)("instruction"),
    (0, import_buffer_layout46.blob)(buf.length, "amount")
  ]);
  const data = Buffer.alloc(uiAmountToAmountInstructionData.span);
  uiAmountToAmountInstructionData.encode({
    instruction: TokenInstruction.UiAmountToAmount,
    amount: buf
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeUiAmountToAmountInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  const uiAmountToAmountInstructionData = (0, import_buffer_layout46.struct)([
    (0, import_buffer_layout46.u8)("instruction"),
    (0, import_buffer_layout46.blob)(instruction.data.length - 1, "amount")
  ]);
  if (instruction.data.length !== uiAmountToAmountInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint }, data } = decodeUiAmountToAmountInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.UiAmountToAmount)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint
    },
    data
  };
}
function decodeUiAmountToAmountInstructionUnchecked({ programId, keys: [mint], data }) {
  const uiAmountToAmountInstructionData = (0, import_buffer_layout46.struct)([
    (0, import_buffer_layout46.u8)("instruction"),
    (0, import_buffer_layout46.blob)(data.length - 1, "amount")
  ]);
  return {
    programId,
    keys: {
      mint
    },
    data: uiAmountToAmountInstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/actions/uiAmountToAmount.js
async function uiAmountToAmount(connection, payer, mint, amount, programId = TOKEN_PROGRAM_ID) {
  const transaction = new Transaction().add(createUiAmountToAmountInstruction(mint, amount, programId));
  const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;
  if (returnData) {
    const data = Buffer.from(returnData.data[0], returnData.data[1]);
    return u64().decode(data);
  }
  return err;
}

// node_modules/@solana/spl-token/lib/esm/extensions/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/groupMemberPointer/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/groupMemberPointer/instructions.js
init_process();
init_buffer();
var import_buffer_layout47 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var GroupMemberPointerInstruction;
(function(GroupMemberPointerInstruction2) {
  GroupMemberPointerInstruction2[GroupMemberPointerInstruction2["Initialize"] = 0] = "Initialize";
  GroupMemberPointerInstruction2[GroupMemberPointerInstruction2["Update"] = 1] = "Update";
})(GroupMemberPointerInstruction || (GroupMemberPointerInstruction = {}));
var initializeGroupMemberPointerData = (0, import_buffer_layout47.struct)([
  // prettier-ignore
  (0, import_buffer_layout47.u8)("instruction"),
  (0, import_buffer_layout47.u8)("groupMemberPointerInstruction"),
  publicKey("authority"),
  publicKey("memberAddress")
]);
function createInitializeGroupMemberPointerInstruction(mint, authority, memberAddress, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeGroupMemberPointerData.span);
  initializeGroupMemberPointerData.encode({
    instruction: TokenInstruction.GroupMemberPointerExtension,
    groupMemberPointerInstruction: GroupMemberPointerInstruction.Initialize,
    authority: authority ?? PublicKey.default,
    memberAddress: memberAddress ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var updateGroupMemberPointerData = (0, import_buffer_layout47.struct)([
  // prettier-ignore
  (0, import_buffer_layout47.u8)("instruction"),
  (0, import_buffer_layout47.u8)("groupMemberPointerInstruction"),
  publicKey("memberAddress")
]);
function createUpdateGroupMemberPointerInstruction(mint, authority, memberAddress, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(updateGroupMemberPointerData.span);
  updateGroupMemberPointerData.encode({
    instruction: TokenInstruction.GroupMemberPointerExtension,
    groupMemberPointerInstruction: GroupMemberPointerInstruction.Update,
    memberAddress: memberAddress ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/groupPointer/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/groupPointer/instructions.js
init_process();
init_buffer();
var import_buffer_layout48 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var GroupPointerInstruction;
(function(GroupPointerInstruction2) {
  GroupPointerInstruction2[GroupPointerInstruction2["Initialize"] = 0] = "Initialize";
  GroupPointerInstruction2[GroupPointerInstruction2["Update"] = 1] = "Update";
})(GroupPointerInstruction || (GroupPointerInstruction = {}));
var initializeGroupPointerData = (0, import_buffer_layout48.struct)([
  // prettier-ignore
  (0, import_buffer_layout48.u8)("instruction"),
  (0, import_buffer_layout48.u8)("groupPointerInstruction"),
  publicKey("authority"),
  publicKey("groupAddress")
]);
function createInitializeGroupPointerInstruction(mint, authority, groupAddress, programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeGroupPointerData.span);
  initializeGroupPointerData.encode({
    instruction: TokenInstruction.GroupPointerExtension,
    groupPointerInstruction: GroupPointerInstruction.Initialize,
    authority: authority ?? PublicKey.default,
    groupAddress: groupAddress ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var updateGroupPointerData = (0, import_buffer_layout48.struct)([
  // prettier-ignore
  (0, import_buffer_layout48.u8)("instruction"),
  (0, import_buffer_layout48.u8)("groupPointerInstruction"),
  publicKey("groupAddress")
]);
function createUpdateGroupPointerInstruction(mint, authority, groupAddress, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(updateGroupPointerData.span);
  updateGroupPointerData.encode({
    instruction: TokenInstruction.GroupPointerExtension,
    groupPointerInstruction: GroupPointerInstruction.Update,
    groupAddress: groupAddress ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMint.js
init_process();
init_buffer();
var import_buffer_layout49 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMintInstructionData = (0, import_buffer_layout49.struct)([
  (0, import_buffer_layout49.u8)("instruction"),
  (0, import_buffer_layout49.u8)("decimals"),
  publicKey("mintAuthority"),
  new COptionPublicKeyLayout("freezeAuthority")
]);
function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(67);
  initializeMintInstructionData.encode({
    instruction: TokenInstruction.InitializeMint,
    decimals,
    mintAuthority,
    freezeAuthority
  }, data);
  return new TransactionInstruction({
    keys,
    programId,
    data: data.subarray(0, initializeMintInstructionData.getSpan(data))
  });
}
function decodeInitializeMintInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeMintInstructionData.getSpan(instruction.data))
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeMint)
    throw new TokenInvalidInstructionTypeError();
  if (!mint || !rent)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint,
      rent
    },
    data
  };
}
function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
  const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMintInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint,
      rent
    },
    data: {
      instruction,
      decimals,
      mintAuthority,
      freezeAuthority
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/instructions.js
init_process();
init_buffer();
var import_buffer_layout50 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var InterestBearingMintInstruction;
(function(InterestBearingMintInstruction2) {
  InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
  InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
})(InterestBearingMintInstruction || (InterestBearingMintInstruction = {}));
var interestBearingMintInitializeInstructionData = (0, import_buffer_layout50.struct)([
  (0, import_buffer_layout50.u8)("instruction"),
  (0, import_buffer_layout50.u8)("interestBearingMintInstruction"),
  // TODO: Make this an optional public key
  publicKey("rateAuthority"),
  (0, import_buffer_layout50.s16)("rate")
]);
var interestBearingMintUpdateRateInstructionData = (0, import_buffer_layout50.struct)([
  (0, import_buffer_layout50.u8)("instruction"),
  (0, import_buffer_layout50.u8)("interestBearingMintInstruction"),
  (0, import_buffer_layout50.s16)("rate")
]);
function createInitializeInterestBearingMintInstruction(mint, rateAuthority, rate, programId = TOKEN_2022_PROGRAM_ID) {
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(interestBearingMintInitializeInstructionData.span);
  interestBearingMintInitializeInstructionData.encode({
    instruction: TokenInstruction.InterestBearingMintExtension,
    interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,
    rateAuthority,
    rate
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function createUpdateRateInterestBearingMintInstruction(mint, rateAuthority, rate, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false }
  ], rateAuthority, multiSigners);
  const data = Buffer.alloc(interestBearingMintUpdateRateInstructionData.span);
  interestBearingMintUpdateRateInstructionData.encode({
    instruction: TokenInstruction.InterestBearingMintExtension,
    interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,
    rate
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/actions.js
async function createInterestBearingMint(connection, payer, mintAuthority, freezeAuthority, rateAuthority, rate, decimals, keypair = Keypair.generate(), confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const mintLen = getMintLen([ExtensionType.InterestBearingConfig]);
  const lamports = await connection.getMinimumBalanceForRentExemption(mintLen);
  const transaction = new Transaction().add(SystemProgram.createAccount({
    fromPubkey: payer.publicKey,
    newAccountPubkey: keypair.publicKey,
    space: mintLen,
    lamports,
    programId
  }), createInitializeInterestBearingMintInstruction(keypair.publicKey, rateAuthority, rate, programId), createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
  await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);
  return keypair.publicKey;
}
async function updateRateInterestBearingMint(connection, payer, mint, rateAuthority, rate, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [rateAuthorityPublicKey, signers] = getSigners(rateAuthority, multiSigners);
  const transaction = new Transaction().add(createUpdateRateInterestBearingMintInstruction(mint, rateAuthorityPublicKey, rate, signers, programId));
  return await sendAndConfirmTransaction(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/extensions/metadataPointer/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/metadataPointer/instructions.js
init_process();
init_buffer();
var import_buffer_layout51 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var MetadataPointerInstruction;
(function(MetadataPointerInstruction2) {
  MetadataPointerInstruction2[MetadataPointerInstruction2["Initialize"] = 0] = "Initialize";
  MetadataPointerInstruction2[MetadataPointerInstruction2["Update"] = 1] = "Update";
})(MetadataPointerInstruction || (MetadataPointerInstruction = {}));
var initializeMetadataPointerData = (0, import_buffer_layout51.struct)([
  // prettier-ignore
  (0, import_buffer_layout51.u8)("instruction"),
  (0, import_buffer_layout51.u8)("metadataPointerInstruction"),
  publicKey("authority"),
  publicKey("metadataAddress")
]);
function createInitializeMetadataPointerInstruction(mint, authority, metadataAddress, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeMetadataPointerData.span);
  initializeMetadataPointerData.encode({
    instruction: TokenInstruction.MetadataPointerExtension,
    metadataPointerInstruction: MetadataPointerInstruction.Initialize,
    authority: authority ?? PublicKey.default,
    metadataAddress: metadataAddress ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
var updateMetadataPointerData = (0, import_buffer_layout51.struct)([
  // prettier-ignore
  (0, import_buffer_layout51.u8)("instruction"),
  (0, import_buffer_layout51.u8)("metadataPointerInstruction"),
  publicKey("metadataAddress")
]);
function createUpdateMetadataPointerInstruction(mint, authority, metadataAddress, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
  const data = Buffer.alloc(updateMetadataPointerData.span);
  updateMetadataPointerData.encode({
    instruction: TokenInstruction.MetadataPointerExtension,
    metadataPointerInstruction: MetadataPointerInstruction.Update,
    metadataAddress: metadataAddress ?? PublicKey.default
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/actions.js
init_process();
init_buffer();
init_index_browser_esm();

// node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/state.js
init_process();
init_buffer();
var getNormalizedTokenMetadataField = (field) => {
  if (field === Field.Name || field === "Name" || field === "name") {
    return "name";
  }
  if (field === Field.Symbol || field === "Symbol" || field === "symbol") {
    return "symbol";
  }
  if (field === Field.Uri || field === "Uri" || field === "uri") {
    return "uri";
  }
  return field;
};
function updateTokenMetadata(current, key, value) {
  const field = getNormalizedTokenMetadataField(key);
  if (field === "mint" || field === "updateAuthority") {
    throw new Error(`Cannot update ${field} via this instruction`);
  }
  if (["name", "symbol", "uri"].includes(field)) {
    return {
      ...current,
      [field]: value
    };
  }
  const additionalMetadata = [...current.additionalMetadata];
  const i = current.additionalMetadata.findIndex((x) => x[0] === field);
  if (i === -1) {
    additionalMetadata.push([field, value]);
  } else {
    additionalMetadata[i] = [field, value];
  }
  return {
    ...current,
    additionalMetadata
  };
}
async function getTokenMetadata(connection, address, commitment, programId = TOKEN_2022_PROGRAM_ID) {
  const mintInfo = await getMint(connection, address, commitment, programId);
  const data = getExtensionData(ExtensionType.TokenMetadata, mintInfo.tlvData);
  if (data === null) {
    return null;
  }
  return unpack(data);
}

// node_modules/@solana/spl-token/lib/esm/state/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/actions.js
async function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = TOKEN_2022_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address);
  if (!info) {
    throw new TokenAccountNotFoundError();
  }
  const extensionLen = pack(tokenMetadata).length;
  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);
  if (newAccountLen <= info.data.length) {
    return 0;
  }
  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);
  return newRentExemptMinimum - info.lamports;
}
async function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = TOKEN_2022_PROGRAM_ID) {
  const info = await connection.getAccountInfo(address);
  if (!info) {
    throw new TokenAccountNotFoundError();
  }
  const mint = unpackMint(address, info, programId);
  const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);
  if (extensionData === null) {
    throw new Error("TokenMetadata extension not initialized");
  }
  const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);
  const extensionLen = pack(updatedTokenMetadata).length;
  const newAccountLen = getNewAccountLenForExtensionLen(info, address, ExtensionType.TokenMetadata, extensionLen, programId);
  if (newAccountLen <= info.data.length) {
    return 0;
  }
  const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);
  return newRentExemptMinimum - info.lamports;
}
async function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);
  const transaction = new Transaction().add(createInitializeInstruction({
    programId,
    metadata: mint,
    updateAuthority,
    mint,
    mintAuthority: mintAuthorityPublicKey,
    name,
    symbol,
    uri
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);
  const transaction = new Transaction();
  const lamports = await getAdditionalRentForNewMetadata(connection, mint, {
    updateAuthority,
    mint,
    name,
    symbol,
    uri,
    additionalMetadata: []
  }, programId);
  if (lamports > 0) {
    transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
  }
  transaction.add(createInitializeInstruction({
    programId,
    metadata: mint,
    updateAuthority,
    mint,
    mintAuthority: mintAuthorityPublicKey,
    name,
    symbol,
    uri
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);
  const transaction = new Transaction().add(createUpdateFieldInstruction({
    programId,
    metadata: mint,
    updateAuthority: updateAuthorityPublicKey,
    field,
    value
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);
  const transaction = new Transaction();
  const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);
  if (lamports > 0) {
    transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
  }
  transaction.add(createUpdateFieldInstruction({
    programId,
    metadata: mint,
    updateAuthority: updateAuthorityPublicKey,
    field,
    value
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);
  const transaction = new Transaction().add(createRemoveKeyInstruction({
    programId,
    metadata: mint,
    updateAuthority: updateAuthorityPublicKey,
    key,
    idempotent
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}
async function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = TOKEN_2022_PROGRAM_ID) {
  const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);
  const transaction = new Transaction().add(createUpdateAuthorityInstruction({
    programId,
    metadata: mint,
    oldAuthority: updateAuthorityPublicKey,
    newAuthority
  }));
  return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);
}

// node_modules/@solana/spl-token/lib/esm/instructions/index.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/instructions/decode.js
init_process();
init_buffer();
var import_buffer_layout54 = __toESM(require_Layout(), 1);

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount2.js
init_process();
init_buffer();
var import_buffer_layout52 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeAccount2InstructionData = (0, import_buffer_layout52.struct)([
  (0, import_buffer_layout52.u8)("instruction"),
  publicKey("owner")
]);
function createInitializeAccount2Instruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeAccount2InstructionData.span);
  initializeAccount2InstructionData.encode({ instruction: TokenInstruction.InitializeAccount2, owner }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeAccount2Instruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeAccount2InstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint, rent }, data } = decodeInitializeAccount2InstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeAccount2)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint || !rent)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint,
      rent
    },
    data
  };
}
function decodeInitializeAccount2InstructionUnchecked({ programId, keys: [account, mint, rent], data }) {
  return {
    programId,
    keys: {
      account,
      mint,
      rent
    },
    data: initializeAccount2InstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount3.js
init_process();
init_buffer();
var import_buffer_layout53 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeAccount3InstructionData = (0, import_buffer_layout53.struct)([
  (0, import_buffer_layout53.u8)("instruction"),
  publicKey("owner")
]);
function createInitializeAccount3Instruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeAccount3InstructionData.span);
  initializeAccount3InstructionData.encode({ instruction: TokenInstruction.InitializeAccount3, owner }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeAccount3Instruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeAccount3InstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account, mint }, data } = decodeInitializeAccount3InstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeAccount3)
    throw new TokenInvalidInstructionTypeError();
  if (!account || !mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account,
      mint
    },
    data
  };
}
function decodeInitializeAccount3InstructionUnchecked({ programId, keys: [account, mint], data }) {
  return {
    programId,
    keys: {
      account,
      mint
    },
    data: initializeAccount3InstructionData.decode(data)
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/decode.js
function decodeInstruction(instruction, programId = TOKEN_PROGRAM_ID) {
  if (!instruction.data.length)
    throw new TokenInvalidInstructionDataError();
  const type = (0, import_buffer_layout54.u8)().decode(instruction.data);
  if (type === TokenInstruction.InitializeMint)
    return decodeInitializeMintInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeAccount)
    return decodeInitializeAccountInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeMultisig)
    return decodeInitializeMultisigInstruction(instruction, programId);
  if (type === TokenInstruction.Transfer)
    return decodeTransferInstruction(instruction, programId);
  if (type === TokenInstruction.Approve)
    return decodeApproveInstruction(instruction, programId);
  if (type === TokenInstruction.Revoke)
    return decodeRevokeInstruction(instruction, programId);
  if (type === TokenInstruction.SetAuthority)
    return decodeSetAuthorityInstruction(instruction, programId);
  if (type === TokenInstruction.MintTo)
    return decodeMintToInstruction(instruction, programId);
  if (type === TokenInstruction.Burn)
    return decodeBurnInstruction(instruction, programId);
  if (type === TokenInstruction.CloseAccount)
    return decodeCloseAccountInstruction(instruction, programId);
  if (type === TokenInstruction.FreezeAccount)
    return decodeFreezeAccountInstruction(instruction, programId);
  if (type === TokenInstruction.ThawAccount)
    return decodeThawAccountInstruction(instruction, programId);
  if (type === TokenInstruction.TransferChecked)
    return decodeTransferCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.ApproveChecked)
    return decodeApproveCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.MintToChecked)
    return decodeMintToCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.BurnChecked)
    return decodeBurnCheckedInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeAccount2)
    return decodeInitializeAccount2Instruction(instruction, programId);
  if (type === TokenInstruction.SyncNative)
    return decodeSyncNativeInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeAccount3)
    return decodeInitializeAccount3Instruction(instruction, programId);
  if (type === TokenInstruction.InitializeMint2)
    return decodeInitializeMint2Instruction(instruction, programId);
  if (type === TokenInstruction.AmountToUiAmount)
    return decodeAmountToUiAmountInstruction(instruction, programId);
  if (type === TokenInstruction.UiAmountToAmount)
    return decodeUiAmountToAmountInstruction(instruction, programId);
  if (type === TokenInstruction.InitializeMultisig2)
    throw new TokenInvalidInstructionTypeError();
  throw new TokenInvalidInstructionTypeError();
}
function isInitializeMintInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeMint;
}
function isInitializeAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeAccount;
}
function isInitializeMultisigInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeMultisig;
}
function isTransferInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Transfer;
}
function isApproveInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Approve;
}
function isRevokeInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Revoke;
}
function isSetAuthorityInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.SetAuthority;
}
function isMintToInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.MintTo;
}
function isBurnInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.Burn;
}
function isCloseAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.CloseAccount;
}
function isFreezeAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.FreezeAccount;
}
function isThawAccountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.ThawAccount;
}
function isTransferCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.TransferChecked;
}
function isApproveCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.ApproveChecked;
}
function isMintToCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.MintToChecked;
}
function isBurnCheckedInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.BurnChecked;
}
function isInitializeAccount2Instruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeAccount2;
}
function isSyncNativeInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.SyncNative;
}
function isInitializeAccount3Instruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeAccount3;
}
function isInitializeMint2Instruction(decoded) {
  return decoded.data.instruction === TokenInstruction.InitializeMint2;
}
function isAmountToUiAmountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.AmountToUiAmount;
}
function isUiamountToAmountInstruction(decoded) {
  return decoded.data.instruction === TokenInstruction.UiAmountToAmount;
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMultisig2.js
init_process();
init_buffer();

// node_modules/@solana/spl-token/lib/esm/instructions/initializeImmutableOwner.js
init_process();
init_buffer();
var import_buffer_layout55 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeImmutableOwnerInstructionData = (0, import_buffer_layout55.struct)([
  (0, import_buffer_layout55.u8)("instruction")
]);
function createInitializeImmutableOwnerInstruction(account, programId) {
  const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeImmutableOwnerInstructionData.span);
  initializeImmutableOwnerInstructionData.encode({
    instruction: TokenInstruction.InitializeImmutableOwner
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializeImmutableOwnerInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeImmutableOwnerInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { account }, data } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeImmutableOwner)
    throw new TokenInvalidInstructionTypeError();
  if (!account)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      account
    },
    data
  };
}
function decodeInitializeImmutableOwnerInstructionUnchecked({ programId, keys: [account], data }) {
  const { instruction } = initializeImmutableOwnerInstructionData.decode(data);
  return {
    programId,
    keys: {
      account
    },
    data: {
      instruction
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializeMintCloseAuthority.js
init_process();
init_buffer();
var import_buffer_layout56 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeMintCloseAuthorityInstructionData = (0, import_buffer_layout56.struct)([
  (0, import_buffer_layout56.u8)("instruction"),
  new COptionPublicKeyLayout("closeAuthority")
]);
function createInitializeMintCloseAuthorityInstruction(mint, closeAuthority, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(34);
  initializeMintCloseAuthorityInstructionData.encode({
    instruction: TokenInstruction.InitializeMintCloseAuthority,
    closeAuthority
  }, data);
  return new TransactionInstruction({
    keys,
    programId,
    data: data.subarray(0, initializeMintCloseAuthorityInstructionData.getSpan(data))
  });
}
function decodeInitializeMintCloseAuthorityInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializeMintCloseAuthorityInstructionData.getSpan(instruction.data))
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint }, data } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializeMintCloseAuthority)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint
    },
    data
  };
}
function decodeInitializeMintCloseAuthorityInstructionUnchecked({ programId, keys: [mint], data }) {
  const { instruction, closeAuthority } = initializeMintCloseAuthorityInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint
    },
    data: {
      instruction,
      closeAuthority
    }
  };
}

// node_modules/@solana/spl-token/lib/esm/instructions/reallocate.js
init_process();
init_buffer();
var import_buffer_layout57 = __toESM(require_Layout(), 1);
init_index_browser_esm();
function createReallocateInstruction(account, payer, extensionTypes, owner, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const baseKeys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
  ];
  const keys = addSigners(baseKeys, owner, multiSigners);
  const reallocateInstructionData = (0, import_buffer_layout57.struct)([
    (0, import_buffer_layout57.u8)("instruction"),
    (0, import_buffer_layout57.seq)((0, import_buffer_layout57.u16)(), extensionTypes.length, "extensionTypes")
  ]);
  const data = Buffer.alloc(reallocateInstructionData.span);
  reallocateInstructionData.encode({ instruction: TokenInstruction.Reallocate, extensionTypes }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializeNonTransferableMint.js
init_process();
init_buffer();
var import_buffer_layout58 = __toESM(require_Layout(), 1);
init_index_browser_esm();
var initializeNonTransferableMintInstructionData = (0, import_buffer_layout58.struct)([
  (0, import_buffer_layout58.u8)("instruction")
]);
function createInitializeNonTransferableMintInstruction(mint, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializeNonTransferableMintInstructionData.span);
  initializeNonTransferableMintInstructionData.encode({
    instruction: TokenInstruction.InitializeNonTransferableMint
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@solana/spl-token/lib/esm/instructions/initializePermanentDelegate.js
init_process();
init_buffer();
var import_buffer_layout59 = __toESM(require_Layout(), 1);
init_index_browser_esm();
init_index_browser_esm();
var initializePermanentDelegateInstructionData = (0, import_buffer_layout59.struct)([
  (0, import_buffer_layout59.u8)("instruction"),
  publicKey("delegate")
]);
function createInitializePermanentDelegateInstruction(mint, permanentDelegate, programId) {
  if (!programSupportsExtensions(programId)) {
    throw new TokenUnsupportedInstructionError();
  }
  const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
  const data = Buffer.alloc(initializePermanentDelegateInstructionData.span);
  initializePermanentDelegateInstructionData.encode({
    instruction: TokenInstruction.InitializePermanentDelegate,
    delegate: permanentDelegate || new PublicKey(0)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}
function decodeInitializePermanentDelegateInstruction(instruction, programId) {
  if (!instruction.programId.equals(programId))
    throw new TokenInvalidInstructionProgramError();
  if (instruction.data.length !== initializePermanentDelegateInstructionData.span)
    throw new TokenInvalidInstructionDataError();
  const { keys: { mint }, data } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);
  if (data.instruction !== TokenInstruction.InitializePermanentDelegate)
    throw new TokenInvalidInstructionTypeError();
  if (!mint)
    throw new TokenInvalidInstructionKeysError();
  return {
    programId,
    keys: {
      mint
    },
    data
  };
}
function decodeInitializePermanentDelegateInstructionUnchecked({ programId, keys: [mint], data }) {
  const { instruction, delegate } = initializePermanentDelegateInstructionData.decode(data);
  return {
    programId,
    keys: {
      mint
    },
    data: {
      instruction,
      delegate
    }
  };
}
export {
  ACCOUNT_SIZE,
  ACCOUNT_TYPE_SIZE,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  AccountLayout,
  AccountState,
  AccountType,
  AuthorityType,
  CPI_GUARD_SIZE,
  CpiGuardInstruction,
  CpiGuardLayout,
  DEFAULT_ACCOUNT_STATE_SIZE,
  DefaultAccountStateInstruction,
  DefaultAccountStateLayout,
  ExtensionType,
  ExtraAccountMetaAccountDataLayout,
  ExtraAccountMetaLayout,
  ExtraAccountMetaListLayout,
  GROUP_MEMBER_POINTER_SIZE,
  GROUP_POINTER_SIZE,
  GroupMemberPointerInstruction,
  GroupMemberPointerLayout,
  GroupPointerInstruction,
  GroupPointerLayout,
  IMMUTABLE_OWNER_SIZE,
  INTEREST_BEARING_MINT_CONFIG_STATE_SIZE,
  ImmutableOwnerLayout,
  InterestBearingMintConfigStateLayout,
  InterestBearingMintInstruction,
  LENGTH_SIZE,
  MAX_FEE_BASIS_POINTS,
  MEMO_TRANSFER_SIZE,
  METADATA_POINTER_SIZE,
  MINT_CLOSE_AUTHORITY_SIZE,
  MINT_SIZE,
  MULTISIG_SIZE,
  MemoTransferInstruction,
  MemoTransferLayout,
  MetadataPointerInstruction,
  MetadataPointerLayout,
  MintCloseAuthorityLayout,
  MintLayout,
  MultisigLayout,
  NATIVE_MINT,
  NATIVE_MINT_2022,
  NON_TRANSFERABLE_ACCOUNT_SIZE,
  NON_TRANSFERABLE_SIZE,
  NonTransferableLayout,
  ONE_IN_BASIS_POINTS,
  PAUSABLE_ACCOUNT_SIZE,
  PAUSABLE_CONFIG_SIZE,
  PERMANENT_DELEGATE_SIZE,
  PausableAccountLayout,
  PausableConfigLayout,
  PausableInstruction,
  PermanentDelegateLayout,
  SCALED_UI_AMOUNT_CONFIG_SIZE,
  ScaledUiAmountConfigLayout,
  ScaledUiAmountInstruction,
  TOKEN_2022_PROGRAM_ID,
  TOKEN_GROUP_MEMBER_SIZE,
  TOKEN_GROUP_SIZE,
  TOKEN_PROGRAM_ID,
  TRANSFER_FEE_AMOUNT_SIZE,
  TRANSFER_FEE_CONFIG_SIZE,
  TRANSFER_HOOK_ACCOUNT_SIZE,
  TRANSFER_HOOK_SIZE,
  TYPE_SIZE,
  TokenAccountNotFoundError,
  TokenError,
  TokenInstruction,
  TokenInvalidAccountDataError,
  TokenInvalidAccountError,
  TokenInvalidAccountOwnerError,
  TokenInvalidAccountSizeError,
  TokenInvalidInstructionDataError,
  TokenInvalidInstructionKeysError,
  TokenInvalidInstructionProgramError,
  TokenInvalidInstructionTypeError,
  TokenInvalidMintError,
  TokenInvalidOwnerError,
  TokenOwnerOffCurveError,
  TokenTransferHookAccountDataNotFound,
  TokenTransferHookAccountNotFound,
  TokenTransferHookInvalidPubkeyData,
  TokenTransferHookInvalidSeed,
  TokenTransferHookPubkeyDataTooSmall,
  TokenUnsupportedInstructionError,
  TransferFeeAmountLayout,
  TransferFeeConfigLayout,
  TransferFeeInstruction,
  TransferHookAccountLayout,
  TransferHookInstruction,
  TransferHookLayout,
  addExtraAccountMetasForExecute,
  amountToUiAmount,
  amountToUiAmountForMintWithoutSimulation,
  amountToUiAmountInstructionData,
  amountToUiAmountWithoutSimulation,
  approve,
  approveChecked,
  approveCheckedInstructionData,
  approveInstructionData,
  burn,
  burnChecked,
  burnCheckedInstructionData,
  burnInstructionData,
  calculateEpochFee,
  calculateFee,
  closeAccount,
  closeAccountInstructionData,
  cpiGuardInstructionData,
  createAccount,
  createAmountToUiAmountInstruction,
  createApproveCheckedInstruction,
  createApproveInstruction,
  createAssociatedTokenAccount,
  createAssociatedTokenAccountIdempotent,
  createAssociatedTokenAccountIdempotentInstruction,
  createAssociatedTokenAccountIdempotentInstructionWithDerivation,
  createAssociatedTokenAccountInstruction,
  createBurnCheckedInstruction,
  createBurnInstruction,
  createCloseAccountInstruction,
  createCreateNativeMintInstruction,
  createDisableCpiGuardInstruction,
  createDisableRequiredMemoTransfersInstruction,
  createEmitInstruction,
  createEnableCpiGuardInstruction,
  createEnableRequiredMemoTransfersInstruction,
  createExecuteInstruction,
  createFreezeAccountInstruction,
  createHarvestWithheldTokensToMintInstruction,
  createInitializeAccount2Instruction,
  createInitializeAccount3Instruction,
  createInitializeAccountInstruction,
  createInitializeDefaultAccountStateInstruction,
  createInitializeGroupInstruction,
  createInitializeGroupMemberPointerInstruction,
  createInitializeGroupPointerInstruction,
  createInitializeImmutableOwnerInstruction,
  createInitializeInstruction,
  createInitializeInterestBearingMintInstruction,
  createInitializeMemberInstruction,
  createInitializeMetadataPointerInstruction,
  createInitializeMint2Instruction,
  createInitializeMintCloseAuthorityInstruction,
  createInitializeMintInstruction,
  createInitializeMultisigInstruction,
  createInitializeNonTransferableMintInstruction,
  createInitializePausableConfigInstruction,
  createInitializePermanentDelegateInstruction,
  createInitializeScaledUiAmountConfigInstruction,
  createInitializeTransferFeeConfigInstruction,
  createInitializeTransferHookInstruction,
  createInterestBearingMint,
  createMint,
  createMintToCheckedInstruction,
  createMintToInstruction,
  createMultisig,
  createNativeMint,
  createNativeMintInstructionData,
  createPauseInstruction,
  createReallocateInstruction,
  createRecoverNestedInstruction,
  createRemoveKeyInstruction,
  createResumeInstruction,
  createRevokeInstruction,
  createSetAuthorityInstruction,
  createSetTransferFeeInstruction,
  createSyncNativeInstruction,
  createThawAccountInstruction,
  createTransferCheckedInstruction,
  createTransferCheckedWithFeeAndTransferHookInstruction,
  createTransferCheckedWithFeeInstruction,
  createTransferCheckedWithTransferHookInstruction,
  createTransferInstruction,
  createUiAmountToAmountInstruction,
  createUpdateAuthorityInstruction,
  createUpdateDefaultAccountStateInstruction,
  createUpdateFieldInstruction,
  createUpdateGroupAuthorityInstruction,
  createUpdateGroupMaxSizeInstruction,
  createUpdateGroupMemberPointerInstruction,
  createUpdateGroupPointerInstruction,
  createUpdateMetadataPointerInstruction,
  createUpdateMultiplierDataInstruction,
  createUpdateRateInterestBearingMintInstruction,
  createUpdateTransferHookInstruction,
  createWithdrawWithheldTokensFromAccountsInstruction,
  createWithdrawWithheldTokensFromMintInstruction,
  createWrappedNativeAccount,
  decodeAmountToUiAmountInstruction,
  decodeAmountToUiAmountInstructionUnchecked,
  decodeApproveCheckedInstruction,
  decodeApproveCheckedInstructionUnchecked,
  decodeApproveInstruction,
  decodeApproveInstructionUnchecked,
  decodeBurnCheckedInstruction,
  decodeBurnCheckedInstructionUnchecked,
  decodeBurnInstruction,
  decodeBurnInstructionUnchecked,
  decodeCloseAccountInstruction,
  decodeCloseAccountInstructionUnchecked,
  decodeFreezeAccountInstruction,
  decodeFreezeAccountInstructionUnchecked,
  decodeHarvestWithheldTokensToMintInstruction,
  decodeHarvestWithheldTokensToMintInstructionUnchecked,
  decodeInitializeAccount2Instruction,
  decodeInitializeAccount2InstructionUnchecked,
  decodeInitializeAccount3Instruction,
  decodeInitializeAccount3InstructionUnchecked,
  decodeInitializeAccountInstruction,
  decodeInitializeAccountInstructionUnchecked,
  decodeInitializeImmutableOwnerInstruction,
  decodeInitializeImmutableOwnerInstructionUnchecked,
  decodeInitializeMint2Instruction,
  decodeInitializeMint2InstructionUnchecked,
  decodeInitializeMintCloseAuthorityInstruction,
  decodeInitializeMintCloseAuthorityInstructionUnchecked,
  decodeInitializeMintInstruction,
  decodeInitializeMintInstructionUnchecked,
  decodeInitializeMultisigInstruction,
  decodeInitializeMultisigInstructionUnchecked,
  decodeInitializePermanentDelegateInstruction,
  decodeInitializePermanentDelegateInstructionUnchecked,
  decodeInitializeTransferFeeConfigInstruction,
  decodeInitializeTransferFeeConfigInstructionUnchecked,
  decodeInstruction,
  decodeMintToCheckedInstruction,
  decodeMintToCheckedInstructionUnchecked,
  decodeMintToInstruction,
  decodeMintToInstructionUnchecked,
  decodeRevokeInstruction,
  decodeRevokeInstructionUnchecked,
  decodeSetAuthorityInstruction,
  decodeSetAuthorityInstructionUnchecked,
  decodeSetTransferFeeInstruction,
  decodeSetTransferFeeInstructionUnchecked,
  decodeSyncNativeInstruction,
  decodeSyncNativeInstructionUnchecked,
  decodeThawAccountInstruction,
  decodeThawAccountInstructionUnchecked,
  decodeTransferCheckedInstruction,
  decodeTransferCheckedInstructionUnchecked,
  decodeTransferCheckedWithFeeInstruction,
  decodeTransferCheckedWithFeeInstructionUnchecked,
  decodeTransferInstruction,
  decodeTransferInstructionUnchecked,
  decodeUiAmountToAmountInstruction,
  decodeUiAmountToAmountInstructionUnchecked,
  decodeWithdrawWithheldTokensFromAccountsInstruction,
  decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked,
  decodeWithdrawWithheldTokensFromMintInstruction,
  decodeWithdrawWithheldTokensFromMintInstructionUnchecked,
  defaultAccountStateInstructionData,
  disableCpiGuard,
  disableRequiredMemoTransfers,
  enableCpiGuard,
  enableRequiredMemoTransfers,
  freezeAccount,
  freezeAccountInstructionData,
  getAccount,
  getAccountLen,
  getAccountLenForMint,
  getAccountTypeOfMintType,
  getAssociatedTokenAddress,
  getAssociatedTokenAddressSync,
  getCpiGuard,
  getDefaultAccountState,
  getEpochFee,
  getExtensionData,
  getExtensionTypes,
  getExtraAccountMetaAddress,
  getExtraAccountMetas,
  getGroupMemberPointerState,
  getGroupPointerState,
  getImmutableOwner,
  getInterestBearingMintConfigState,
  getMemoTransfer,
  getMetadataPointerState,
  getMinimumBalanceForRentExemptAccount,
  getMinimumBalanceForRentExemptAccountWithExtensions,
  getMinimumBalanceForRentExemptMint,
  getMinimumBalanceForRentExemptMintWithExtensions,
  getMinimumBalanceForRentExemptMultisig,
  getMint,
  getMintCloseAuthority,
  getMintLen,
  getMultipleAccounts,
  getMultisig,
  getNewAccountLenForExtensionLen,
  getNonTransferable,
  getNonTransferableAccount,
  getOrCreateAssociatedTokenAccount,
  getPausableAccount,
  getPausableConfig,
  getPermanentDelegate,
  getScaledUiAmountConfig,
  getTokenGroupMemberState,
  getTokenGroupState,
  getTokenMetadata,
  getTransferFeeAmount,
  getTransferFeeConfig,
  getTransferHook,
  getTransferHookAccount,
  getTypeLen,
  harvestWithheldTokensToMint,
  harvestWithheldTokensToMintInstructionData,
  initializeAccount2InstructionData,
  initializeAccount3InstructionData,
  initializeAccountInstructionData,
  initializeDefaultAccountState,
  initializeGroupMemberPointerData,
  initializeGroupPointerData,
  initializeImmutableOwnerInstructionData,
  initializeMetadataPointerData,
  initializeMint2InstructionData,
  initializeMintCloseAuthorityInstructionData,
  initializeMintInstructionData,
  initializeMultisigInstructionData,
  initializeNonTransferableMintInstructionData,
  initializePausableConfigInstructionData,
  initializePermanentDelegateInstructionData,
  initializeScaledUiAmountConfigInstructionData,
  initializeTransferFeeConfigInstructionData,
  initializeTransferHook,
  initializeTransferHookInstructionData,
  interestBearingMintInitializeInstructionData,
  interestBearingMintUpdateRateInstructionData,
  isAccountExtension,
  isAmountToUiAmountInstruction,
  isApproveCheckedInstruction,
  isApproveInstruction,
  isBurnCheckedInstruction,
  isBurnInstruction,
  isCloseAccountInstruction,
  isFreezeAccountInstruction,
  isInitializeAccount2Instruction,
  isInitializeAccount3Instruction,
  isInitializeAccountInstruction,
  isInitializeMint2Instruction,
  isInitializeMintInstruction,
  isInitializeMultisigInstruction,
  isMintExtension,
  isMintToCheckedInstruction,
  isMintToInstruction,
  isRevokeInstruction,
  isSetAuthorityInstruction,
  isSyncNativeInstruction,
  isThawAccountInstruction,
  isTransferCheckedInstruction,
  isTransferInstruction,
  isUiamountToAmountInstruction,
  memoTransferInstructionData,
  mintTo,
  mintToChecked,
  mintToCheckedInstructionData,
  mintToInstructionData,
  pause,
  pauseInstructionData,
  programSupportsExtensions,
  recoverNested,
  resolveExtraAccountMeta,
  resume,
  resumeInstructionData,
  revoke,
  revokeInstructionData,
  setAuthority,
  setAuthorityInstructionData,
  setTransferFee,
  setTransferFeeInstructionData,
  syncNative,
  syncNativeInstructionData,
  thawAccount,
  thawAccountInstructionData,
  tokenGroupInitializeGroup,
  tokenGroupInitializeGroupWithRentTransfer,
  tokenGroupMemberInitialize,
  tokenGroupMemberInitializeWithRentTransfer,
  tokenGroupUpdateGroupAuthority,
  tokenGroupUpdateGroupMaxSize,
  tokenMetadataInitialize,
  tokenMetadataInitializeWithRentTransfer,
  tokenMetadataRemoveKey,
  tokenMetadataUpdateAuthority,
  tokenMetadataUpdateField,
  tokenMetadataUpdateFieldWithRentTransfer,
  transfer,
  transferChecked,
  transferCheckedInstructionData,
  transferCheckedWithFee,
  transferCheckedWithFeeAndTransferHook,
  transferCheckedWithFeeInstructionData,
  transferCheckedWithTransferHook,
  transferFeeLayout,
  transferInstructionData,
  uiAmountToAmount,
  uiAmountToAmountForMintWithoutSimulation,
  uiAmountToAmountWithoutSimulation,
  unpackAccount,
  unpackMint,
  unpackMultisig,
  unpackPubkeyData,
  unpackSeeds,
  updateDefaultAccountState,
  updateGroupMemberPointerData,
  updateGroupPointerData,
  updateMetadataPointerData,
  updateMultiplier,
  updateMultiplierData,
  updateRateInterestBearingMint,
  updateTokenMetadata,
  updateTransferHook,
  updateTransferHookInstructionData,
  withdrawWithheldTokensFromAccounts,
  withdrawWithheldTokensFromAccountsInstructionData,
  withdrawWithheldTokensFromMint,
  withdrawWithheldTokensFromMintInstructionData
};
//# sourceMappingURL=@solana_spl-token.js.map
